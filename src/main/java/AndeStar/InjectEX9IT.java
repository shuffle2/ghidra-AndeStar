package AndeStar;

import java.lang.reflect.Array;
import java.math.BigInteger;
import java.util.Arrays;

import ghidra.app.plugin.processors.sleigh.SleighLanguage;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressSpace;
import ghidra.program.model.lang.InjectContext;
import ghidra.program.model.lang.InjectPayloadCallother;
import ghidra.program.model.listing.*;
import ghidra.program.model.lang.Register;
import ghidra.program.model.pcode.PcodeOp;
import ghidra.app.util.PseudoDisassembler;
import ghidra.app.util.PseudoInstruction;

public class InjectEX9IT extends InjectPayloadCallother {
	private PcodeOp[] EMPTY_PCODEOP = new PcodeOp[0];
	private int INSTRUCTION_TABLE_ENTRY_LENGTH = 4;
	private AddressSpace defaultSpace;
	private CodeUnitFormat codeUnitFormat;
	private Register itbReg;

	public InjectEX9IT(String sourceName, SleighLanguage language) {
		super(sourceName);
		itbReg = language.getRegister("ITB");
		defaultSpace = language.getAddressFactory().getDefaultAddressSpace();
		codeUnitFormat = new CodeUnitFormat(new CodeUnitFormatOptions());
	}

	PseudoInstruction disasmAt(Program program, Address disasmAddr, Address fetchAddr) {
		PseudoDisassembler disassembler = new PseudoDisassembler(program);
		byte[] data = new byte[INSTRUCTION_TABLE_ENTRY_LENGTH];
		try {
			if (program.getMemory().getBytes(fetchAddr, data) != Array.getLength(data)) {
				return null;
			}
			return disassembler.disassemble(disasmAddr, data);
		} catch (Exception ex) {
			return null;
		}
	}

	@Override
	public PcodeOp[] getPcode(Program program, InjectContext con) {
		Address ex9itAddr = con.baseAddr;
		int imm9u = (int) con.inputlist.get(0).getOffset();
		int itOffset = imm9u * INSTRUCTION_TABLE_ENTRY_LENGTH;

		BigInteger ITB = program.getProgramContext().getValue(itbReg, ex9itAddr, false);
		if (ITB == null) {
			return EMPTY_PCODEOP;
		}
		long memOffset = (ITB.longValue() & ~0b11) + itOffset;

		Address fetchAddr = defaultSpace.getAddress(memOffset);
		// HACK: disasm at addr 0 to make J/JAL work. Might make other things using
		// inst_start incorrect.
		// XXX this is STILL broken. disasm comment will be wrong, but pcode will be
		// correct.
		// I guess there's some caching behavior somewhere that fucks up the comment
		// generated by getRepresentationString.
		PseudoInstruction insn = disasmAt(program, defaultSpace.getAddress(0), fetchAddr);
		// Could be bad ITB
		if (insn == null) {
			return EMPTY_PCODEOP;
		}

		String mnem = insn.getMnemonicString();
		if (mnem == "EX9.IT") {
			// hw would generate Reserved Instruction Exception
			return EMPTY_PCODEOP;
		}

		// 32bit insns which use inst_next (PC + 4) need to be fixed up to use PC + 2,
		// since EX9.IT is 16bit.
		// if J : PC = concat(PC[31,25], (Inst[23,0] << 1)) // not signed?
		// if JAL : R30 = PC + 2; PC = concat(PC[31,25], (Inst[23,0] << 1))
		// JRAL, JRAL.xTON, JRALNEZ, BGEZAL, BLTZAL: RT = PC + 2
		// TODO This is still not fixed (the ITMode=1 sleigh code is never reached)

		// Set comment if there's a valid insn referenced.
		// TODO append the referenced instruction in a more disassembler-aware way
		Listing listing = program.getListing();
		if (listing.getComment(CodeUnit.EOL_COMMENT, ex9itAddr) == null) {
			// getRepresentationString is also slow
			String ex9itComment = codeUnitFormat.getRepresentationString(insn);
			program.withTransaction("set EX9.IT comment", () -> {
				listing.setComment(ex9itAddr, CodeUnit.EOL_COMMENT,
						String.format("%s {%s}", fetchAddr.toString(), ex9itComment));
			});
		}

		return insn.getPcode();
	}

}
