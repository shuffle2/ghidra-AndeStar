# instruction endianness is always big, but data load/store endian is controlled by PSW.BE
# PSW.BE reset value is implementation defined, so it is useful to provide language specs defaulting each way
define endian=$(ENDIAN);
define alignment=2;

define space ram        type=ram_space      size=4 default;
define space register   type=register_space size=4;

# GPRs
define register offset=0 size=4 [
    a0 a1 a2 a3 a4 a5
    s0 s1 s2 s3 s4 s5 s6 s7 s8
    ta
    t0 t1 t2 t3 t4 t5 t6 t7 t8 t9
    p0 p1
    fp gp lp sp
];

# USRs (User Special Registers)
define register offset=0x80 size=8 [d0 d1];
define register offset=0x80 size=4 [
    # Group 0
    d0.hi d0.lo d1.hi d1.lo
    LB LE LC
    ITB IFC_LP PC
    # Group 1
    DMA_CFG DMA_GCSW DMA_CHNSEL DMA_ACT DMA_SETUP DMA_ISADDR DMA_ESADDR DMA_TCNT DMA_STATUS DMA_2DSET
    DMA_2DSCTL
    # Group 2
    PFMC0 PFMC1 PFMC2
    PFM_CTL
];

# TODO implement SRs. hacky impl for IRET for now
# SR Encoding is 10bits. 3 Major, 4 Minor, 3 Extension
# PSW = ir0 (1, 0, 0)
# IPC = ir9 (1, 0, 1)
define register offset=0x100 size=4 [PSW IPC];
# seen SRs
# 0x008  (0, 1, 0)    ICM_CFG
# 0x010  (0, 2, 0)    DCM_CFG
# 0x080  (1, 0, 0)    PSW
# 0x081  (1, 0, 1)    IPSW
# 0x089  (1, 1, 1)    IVB
# 0x091  (1, 2, 1)    EVA
# 0x099  (1, 3, 1)    ITYPE
# 0x0a9  (1, 5, 1)    IPC
# 0x0c0  (1, 8, 0)    INT_MASK
# 0x100  (2, 0, 0)    MMU_CTL
# 0x138  (2, 7, 0)    DLMB
# 0x140  (2, 8, 0)    CACHE_CTL
# 0x178  (2, 15, 0)   SDZ_CTL
# 0x179  (2, 15, 1)   MISC_CTL
# 0x200  (4, 0, 0)    PFMC0
# 0x201  (4, 0, 1)    PFMC1
# 0x202  (4, 0, 2)    PFMC2
# 0x208  (4, 1, 0)    PFM_CTL

# NOTE other languages use @defines instead of bitrange - why?
define bitrange
    PSW.GIE     =PSW[0,1]
    PSW.INTL    =PSW[1,2]
    PSW.POM     =PSW[3,2]
    PSW.BE      =PSW[5,1]
    PSW.IT      =PSW[6,1]
    PSW.DT      =PSW[7,1]
    PSW.IME     =PSW[8,1]
    PSW.DME     =PSW[9,1]
    PSW.DEX     =PSW[10,1]
    PSW.HSS     =PSW[11,1]
    PSW.DRBE    =PSW[12,1]
    PSW.AEN     =PSW[13,1]
    PSW.WBNA    =PSW[14,1]
    PSW.IFCON   =PSW[15,1]
    PSW.CPL     =PSW[16,2]
    PSW.OV      =PSW[20,1]
    PSW.PFT_EN  =PSW[21,1]
    PSW.PNP     =PSW[22,1];

#@define PSW.GIE     "PSW[0,1]"
#@define PSW.INTL    "PSW[1,2]"
#@define PSW.POM     "PSW[3,2]"
#@define PSW.BE      "PSW[5,1]"
#@define PSW.IT      "PSW[6,1]"
#@define PSW.DT      "PSW[7,1]"
#@define PSW.IME     "PSW[8,1]"
#@define PSW.DME     "PSW[9,1]"
#@define PSW.DEX     "PSW[10,1]"
#@define PSW.HSS     "PSW[11,1]"
#@define PSW.DRBE    "PSW[12,1]"
#@define PSW.AEN     "PSW[13,1]"
#@define PSW.WBNA    "PSW[14,1]"
#@define PSW.IFCON   "PSW[15,1]"
#@define PSW.CPL     "PSW[16,2]"
#@define PSW.OV      "PSW[20,1]"
#@define PSW.PFT_EN  "PSW[21,1]"
#@define PSW.PNP     "PSW[22,1]"

# ghidra state
define register offset=0x110 size=4 [bi_addr];

# valid if isa=0
define token instr32(32) endian=big
    isa         = (31,31)
    opc         = (25,30)
    subop       = (0,4)
    subop0_5    = (0,5)

    dtlo21 = (21,21)
    dt21 = (21,21)

    hwgp18_19=(18,19)
    hwgp17_19=(17,19)

    u6_9 = (6,9)
    lmw_fp=(9,9)
    lmw_gp=(8,8)
    lmw_lp=(7,7)
    lmw_sp=(6,6)
    lmw5 = (5,5)
    lmw4 = (4,4)
    lmw3=(3,3)
    lmw2=(2,2)
    u0_1=(0,1)

    setend20=(20,20)
    setgie20=(20,20)

    dprefi24=(24,24)
    dpref20_23=(20,23)

    standby5_6=(5,6)

    u22_24=(22,24)
    u21_24=(21,24)
    u20_20=(20,20)
    u6_14=(6,14)

    u24_24  = (24,24)
    u20_24  = (20,24)
    u20_24i = (20,24)
    u19_19  = (19,19)
    u15_24  = (15,24)
    u20_23  = (20,23)
    u16_19  = (16,19)
    u15_19  = (15,19)
    u15_19i = (15,19)
    u5_19   =  (5,19)
    u5_14   =  (5,14)
    u14_14  = (14,14)
    u11_14  = (11,14)
    u10_19  = (10,19)
    u10_14  = (10,14)
    u10_14i = (10,14)
    u10_10  = (10,10)
    s8_18   =  (8,18) signed
    u0_19   =  (0,19)
    s0_19   =  (0,19) signed
    u0_14   =  (0,14)
    s0_23   =  (0,23) signed
    s0_18   =  (0,18) signed
    s0_17   =  (0,17) signed
    s0_16   =  (0,16) signed
    s0_15   =  (0,15) signed
    s0_14   =  (0,14) signed
    s0_13   =  (0,13) signed
    u8_9    =   (8,9)
    u7_9    =   (7,9)
    u5_9    =   (5,9)
    u5_9i   =   (5,9)
    u6_7    =   (6,7)
    s0_7    =   (0,7) signed
    u0_7    =   (0,7)
    u0_5    =   (0,5)
    u5_7    =   (5,7)
    u5_5    =   (5,5)
;

# valid if isa_s=1
define token instr16(16) endian=big
    isa_s = (15,15)

    op11_14 = (11,14)
    op10_14 = (10,14)
    op9_14 = (9,14)
    op8_14 = (8,14)
    op7_14 = (7,14)
    op5_14 = (5,14)
    subop0_2 = (0,2)

    R5_5_9 = (5,9)
    R5_0_4 = (0,4)

    R4_5_8 = (5,8)
    R4_4_7 = (4,7)
    R4_0_3 = (0,3)

    R3_8_10 = (8,10)
    R3_6_8 = (6,8)
    R3_3_5 = (3,5)
    R3_0_2 = (0,2)

    R2_5_6 = (5,6)

    imm4u = (5,8)

    imm9u = (0,8)
    imm9s = (0,8) signed
    imm10s = (0,9) signed
    imm8s = (0,7) signed
    imm7u = (0,6)
    imm6u = (0,5)
    imm5u = (0,4)
    imm5s = (0,4) signed
    imm3u = (0,2)

    lwi37 = (7,7)
;

# GPRs - 32/16bit instructions, 5bit index
attach variables [
    u20_24 u15_19 u10_14 u5_9
    R5_5_9 R5_0_4
] [
    a0 a1 a2 a3 a4 a5
    s0 s1 s2 s3 s4 s5 s6 s7 s8
    ta
    t0 t1 t2 t3 t4 t5 t6 t7 t8 t9
    p0 p1
    fp gp lp sp
];
# GPRs - 16bit instruction, 4bit index
attach variables [R4_5_8] [
    a0 a1 a2 a3 a4 a5
    s0 s1 s2 s3 s4 s5
    t0 t1 t2 t3
];
# GPRs - 16bit instruction, 3bit index
attach variables [R3_0_2 R3_3_5 R3_6_8 R3_8_10] [
    a0 a1 a2 a3 a4 a5
    s0 s1
];
attach variables [R2_5_6] [
    s0 s2 s4 s8
];
# These fields index even registers
attach variables [R4_0_3 R4_4_7] [
    a0 a2 a4
    s0 s2 s4 s6 s8
    t0 t2 t4 t6 t8
    p0
    fp lp
];

# USRs
attach variables [dtlo21] [d0.lo d1.lo];
attach variables [dt21] [d0 d1];

attach names [setend20] [L B];
attach names [setgie20] [D E];
attach names [dprefi24] [w d];
attach names [dpref20_23] [
    SRD MRD SWR MWR PTE CLWR
    ImpDep6 ImpDep7 ImpDep8 ImpDep9 ImpDep10
    ImpDep11 ImpDep12 ImpDep13 ImpDep14 ImpDep15
];
attach names [standby5_6] [no_wake_grant wake_grant wait_done reserved];
attach names [lmw2] ["" m];
attach names [lmw3] [i d];
attach names [lmw4] [b a];

define pcodeop Exception_Breakpoint;
define pcodeop Exception_System_Call;
define pcodeop Exception_Trap;
define pcodeop cctl;
define pcodeop dsb;
define pcodeop isb;
define pcodeop isync;
define pcodeop mfsr;
define pcodeop mtsr;
define pcodeop setend;
define pcodeop setgie;
define pcodeop standby;
define pcodeop lmw;
define pcodeop smw;
define pcodeop ex9it;

# TODO since IFCON changes so much behavior, maybe should be treated as context?
# but, we expect insns at same addr to be encountered with IFCON 0/1, not sure if that's acceptable.
macro psw_ifcon_clear() {
    PSW.IFCON = 0;
}

with : isa=0 {
    # ALU_1
    with : opc=0b100000 & u5_9i=0 {
        :ADD   u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00000 { u20_24 =   u15_19 + u10_14; }
        :AND   u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00010 { u20_24 =   u15_19 & u10_14; }
        :OR    u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00100 { u20_24 =   u15_19 | u10_14; }
        :XOR   u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00011 { u20_24 =   u15_19 ^ u10_14; }
        :NOR   u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00101 { u20_24 = ~(u15_19 | u10_14); }
        :ROTR  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b01111 {
            local ra = u10_14[0,5];
            u20_24 = (u15_19 >> ra) | (u15_19 << (32 - ra));
        }
        :ROTRI u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i & subop=0b01011 {
            local ra = u10_14i;
            u20_24 = (u15_19 >> ra) | (u15_19 << (32 - ra));
        }
        :CMOVN u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b11011 {
            if (!(u10_14 != 0)) goto <end>;
            u20_24 = u15_19;
            <end>
        }
        :CMOVZ u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b11010 {
            if (!(u10_14 == 0)) goto <end>;
            u20_24 = u15_19;
            <end>
        }
        :SEB u20_24, u15_19 is u20_24 & u15_19 & u5_14=0 & subop=0b10000 { u20_24 = sext(u15_19:1); }
        :SEH u20_24, u15_19 is u20_24 & u15_19 & u5_14=0 & subop=0b10001 { u20_24 = sext(u15_19:2); }
        :ZEH u20_24, u15_19 is u20_24 & u15_19 & u5_14=0 & subop=0b10011 { u20_24 = zext(u15_19:2); }

        :SLL  u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14  & subop=0b01100 { u20_24 = u15_19 << u10_14[0,5]; }
        :SLLI u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i & subop=0b01000 {
            local sa:4 = u10_14i;
            u20_24 = u15_19 << sa[0,5];
        }
        :SRA  u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14  & subop=0b01110 { u20_24 = u15_19 s>> u10_14[0,5]; }
        :SRAI u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i & subop=0b01010 {
            local sa:4 = u10_14i;
            u20_24 = u15_19 s>> sa[0,5];
        }
        :SRL  u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14  & subop=0b01101 { u20_24 = u15_19 >> u10_14[0,5]; }
        :SRLI u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i & subop=0b01001 {
            local sa:4 = u10_14i;
            u20_24 = u15_19 >> sa[0,5];
        }
        :NOP is u20_24=0 & u15_19=0 & u10_14=0 & subop=0b01001 {}

        :SLT  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00110 { u20_24 = zext(u15_19  < u10_14); }
        :SLTS u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00111 { u20_24 = zext(u15_19 s< u10_14); }

        :SUB  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00001 { u20_24 = u15_19 - u10_14; }
        :SVA  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b11000 { u20_24 = zext(scarry(u15_19, u10_14)); }
        :SVS  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b11001 { u20_24 = zext(sborrow(u15_19, u10_14)); }
        :WSBH u20_24, u15_19 is u20_24 & u15_19 & u10_14=0 & subop=0b10100 {
            u20_24 =
                ((u15_19 & 0x000000ff) << 8) |
                ((u15_19 & 0x0000ff00) >> 8) |
                ((u15_19 & 0x00ff0000) << 8) |
                ((u15_19 & 0xff000000) >> 8);
        }
    }
    # ALU_2
    with : opc=0b100001 {
        :BTST u20_24, u15_19, u0_5 is u20_24 & u15_19 & u0_5 & subop0_5=0b001011 {
            u20_24 = zext((u15_19 & (1 << u0_5)) != 0);
        }
        :MUL u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & u6_9=0 & subop0_5=0b100100 { u20_24 = u15_19 * u10_14; }
        :MADD32 dtlo21, u15_19, u10_14  is u22_24=0 & dtlo21 & u20_20=0 & u15_19 & u10_14 & u6_9=0 & subop0_5=0b110011 {
            local a = u15_19;
            local b = u10_14;
            local m = a * b;
            dtlo21 = dtlo21 + m;
        }
        :MADD64 dt21, u15_19, u10_14    is u22_24=0 & dt21   & u20_20=0 & u15_19 & u10_14 & u6_9=0 & subop0_5=0b101011 {
            local a:8 = zext(u15_19);
            local b:8 = zext(u10_14);
            local m:8 = a * b;
            dt21 = dt21 + m;
        }
        :MADDS64 dt21, u15_19, u10_14   is u22_24=0 & dt21   & u20_20=0 & u15_19 & u10_14 & u6_9=0 & subop0_5=0b101010 {
            local a:8 = sext(u15_19);
            local b:8 = sext(u10_14);
            local m:8 = a * b;
            dt21 = dt21 + m;
        }

        USR_Name: d0.hi         is d0.hi    & u10_14i=0 & u15_19i=0 { export d0.hi; }
        USR_Name: d0.lo         is d0.lo    & u10_14i=0 & u15_19i=1 { export d0.lo; }
        USR_Name: d1.hi         is d1.hi    & u10_14i=0 & u15_19i=2 { export d1.hi; }
        USR_Name: d1.lo         is d1.lo    & u10_14i=0 & u15_19i=3 { export d1.lo; }
        USR_Name: LB            is LB       & u10_14i=0 & u15_19i=25 { export LB; }
        USR_Name: LE            is LE       & u10_14i=0 & u15_19i=26 { export LE; }
        USR_Name: LC            is LC       & u10_14i=0 & u15_19i=27 { export LC; }
        USR_Name: ITB           is ITB      & u10_14i=0 & u15_19i=28 { export ITB; }
        USR_Name: IFC_LP        is IFC_LP   & u10_14i=0 & u15_19i=29 { export IFC_LP; }
        USR_Name: PC            is PC       & u10_14i=0 & u15_19i=31 { export PC; }
        USR_Name: DMA_CFG       is DMA_CFG      & u10_14i=1 & u15_19i=0 { export DMA_CFG; }
        USR_Name: DMA_GCSW      is DMA_GCSW     & u10_14i=1 & u15_19i=1 { export DMA_GCSW; }
        USR_Name: DMA_CHNSEL    is DMA_CHNSEL   & u10_14i=1 & u15_19i=2 { export DMA_CHNSEL; }
        USR_Name: DMA_ACT       is DMA_ACT      & u10_14i=1 & u15_19i=3 { export DMA_ACT; }
        USR_Name: DMA_SETUP     is DMA_SETUP    & u10_14i=1 & u15_19i=4 { export DMA_SETUP; }
        USR_Name: DMA_ISADDR    is DMA_ISADDR   & u10_14i=1 & u15_19i=5 { export DMA_ISADDR; }
        USR_Name: DMA_ESADDR    is DMA_ESADDR   & u10_14i=1 & u15_19i=6 { export DMA_ESADDR; }
        USR_Name: DMA_TCNT      is DMA_TCNT     & u10_14i=1 & u15_19i=7 { export DMA_TCNT; }
        USR_Name: DMA_STATUS    is DMA_STATUS   & u10_14i=1 & u15_19i=8 { export DMA_STATUS; }
        USR_Name: DMA_2DSET     is DMA_2DSET    & u10_14i=1 & u15_19i=9 { export DMA_2DSET; }
        USR_Name: DMA_2DSCTL    is DMA_2DSCTL   & u10_14i=1 & u15_19i=25 { export DMA_2DSCTL; }
        USR_Name: PFMC0    is PFMC0   & u10_14i=2 & u15_19i=0 { export PFMC0; }
        USR_Name: PFMC1    is PFMC1   & u10_14i=2 & u15_19i=1 { export PFMC1; }
        USR_Name: PFMC2    is PFMC2   & u10_14i=2 & u15_19i=2 { export PFMC2; }
        USR_Name: PFM_CTL  is PFM_CTL & u10_14i=2 & u15_19i=4 { export PFM_CTL; }
        :MFUSR u20_24, USR_Name is u20_24 & USR_Name & u6_9=0 & subop0_5=0b100000 { u20_24 = USR_Name; }
        :MFUSR u20_24, (= u15_19i, u10_14i) is u20_24 & u15_19i & u10_14i & u6_9=0 & subop0_5=0b100000 unimpl
        :MTUSR u20_24, USR_Name is u20_24 & USR_Name & u6_9=0 & subop0_5=0b100001 { USR_Name = u20_24; }
        :MTUSR u20_24, (= u15_19i, u10_14i) is u20_24 & u15_19i & u10_14i & u6_9=0 & subop0_5=0b100001 unimpl
    }

    # compute relative targets for branches
    imm14s_rel: rel is s0_13 [ rel = inst_start + (s0_13 << 1); ] { export *:4 rel; }
    imm16s_rel: rel is s0_15 [ rel = inst_start + (s0_15 << 1); ] { export *:4 rel; }
    imm24s_rel: rel is s0_23 [ rel = inst_start + (s0_23 << 1); ] { export *:4 rel; }

    # BR1
    with : opc=0b100110 {
        :BEQ u20_24, u15_19, imm14s_rel is u20_24 & u15_19 & u14_14=0 & imm14s_rel {
            if (u20_24 != u15_19) goto <end>;
                psw_ifcon_clear();
                goto imm14s_rel;
            <end>
        }
        :BNE u20_24, u15_19, imm14s_rel is u20_24 & u15_19 & u14_14=1 & imm14s_rel {
            if (u20_24 == u15_19) goto <end>;
                psw_ifcon_clear();
                goto imm14s_rel;
            <end>
        }
    }
    # BR2
    with : opc=0b100111 {
        macro branch_if(cond, target) {
            if (cond) goto <taken>;
                goto <end>;
            <taken>
            psw_ifcon_clear();
            goto target;
            <end>
        }
        macro call_if(cond, target) {
            if (cond) goto <taken>;
                goto <end>;
            <taken>
            psw_ifcon_clear();
            call target;
            <end>
        }
        macro set_link_gpr(gpr, target) {
            if (PSW.IFCON) goto <ifcon>;
                gpr = target;
                goto <fi>;
            <ifcon>
                gpr = IFC_LP;
            <fi>
        }
        :BEQZ u20_24, imm16s_rel is u20_24 & u16_19=0b0010 & imm16s_rel { branch_if(u20_24 == 0, imm16s_rel); }
        :BNEZ u20_24, imm16s_rel is u20_24 & u16_19=0b0011 & imm16s_rel { branch_if(u20_24 != 0, imm16s_rel); }
        :BGEZ u20_24, imm16s_rel is u20_24 & u16_19=0b0100 & imm16s_rel { branch_if(u20_24 s>= 0, imm16s_rel); }
        :BLTZ u20_24, imm16s_rel is u20_24 & u16_19=0b0101 & imm16s_rel { branch_if(u20_24 s< 0, imm16s_rel); }
        :BGTZ u20_24, imm16s_rel is u20_24 & u16_19=0b0110 & imm16s_rel { branch_if(u20_24 s> 0, imm16s_rel); }
        :BLEZ u20_24, imm16s_rel is u20_24 & u16_19=0b0111 & imm16s_rel { branch_if(u20_24 s<= 0, imm16s_rel); }
        :BGEZAL u20_24, imm16s_rel is u20_24 & u16_19=0b1100 & imm16s_rel {
            local bcond = u20_24;
            set_link_gpr(lp, inst_next);
            call_if(bcond s>= 0, imm16s_rel);
        }
        :BLTZAL u20_24, imm16s_rel is u20_24 & u16_19=0b1101 & imm16s_rel {
            local bcond = u20_24;
            set_link_gpr(lp, inst_next);
            call_if(bcond s< 0, imm16s_rel);
        }
    }
    # JI
    with : opc=0b100100 {
        :J   imm24s_rel is u24_24=0 & imm24s_rel { psw_ifcon_clear(); goto imm24s_rel; }
        :JAL imm24s_rel is u24_24=1 & imm24s_rel {
            set_link_gpr(lp, inst_next);
            psw_ifcon_clear();
            call imm24s_rel;
        }
    }
    # JREG
    with : opc=0b100101 {
        :JR  u10_14 is u15_24=0 & u10_14 & u8_9=0 & u6_7=0 & u5_5=0 & subop=0b00000 {
            psw_ifcon_clear();
            goto [u10_14];
        }
        :RET u10_14 is u15_24=0 & u10_14 & u8_9=0 & u6_7=0 & u5_5=1 & subop=0b00000 {
            psw_ifcon_clear();
            return [u10_14];
        }
        :JR."[T|IT]OFF" u10_14 is u15_24=0 & u10_14 & (u8_9=0b01 | u8_9=0b11) & u6_7=0 & u5_5=0 & subop=0b00000 {
            #PSW.IT = 0;
            #if (!(u8_9 == 0b11)) goto <do_branch>;
            #    PSW.DT = 0;
            #<do_branch>
            psw_ifcon_clear();
            goto [u10_14];
        }
        :JRAL u20_24, u10_14 is u20_24    & u15_19=0 & u10_14 & u8_9=0 & u5_7=0 & subop=0b00001 {
            local jaddr:4 = u10_14;
            set_link_gpr(u20_24, inst_next);
            psw_ifcon_clear();
            goto [jaddr];
        }
        # special case for call (Rt=LP)
        :JRAL u10_14         is u20_24i=30 & u15_19=0 & u10_14 & u8_9=0 & u5_7=0 & subop=0b00001 {
            local jaddr:4 = u10_14;
            set_link_gpr(lp, inst_next);
            psw_ifcon_clear();
            call [jaddr];
        }
        # special case for return (from leaf function: Rt=LP, Rb=LP)
        :JRAL u10_14         is u20_24i=30 & u15_19=0 & u10_14 & u10_14i=30 & u8_9=0 & u5_7=0 & subop=0b00001 {
            local jaddr:4 = u10_14;
            set_link_gpr(lp, inst_next);
            psw_ifcon_clear();
            # TODO ensure correct in IFC case (gdb has probably incorrect behavior of Rt=IFC_LP *after* Rb is read for jaddr, which we replicate)
            return [jaddr];
        }
        :JRAL."[T|IT]ON" u20_24, u10_14 is u20_24     & u15_19=0 & u10_14 & (u8_9=0b01 | u8_9=0b11) & u6_7=0 & u5_5=0 & subop=0b00000 {
            #PSW.IT = 1;
            #if (!(u8_9 == 0b11)) goto <do_branch>;
            #    PSW.DT = 1;
            #<do_branch>
            local jaddr:4 = u10_14;
            set_link_gpr(u20_24, inst_next);
            psw_ifcon_clear();
            goto [jaddr];
        }
        # special case for call
        :JRAL."[T|IT]ON" u10_14         is u20_24i=30 & u15_19=0 & u10_14 & (u8_9=0b01 | u8_9=0b11) & u6_7=0 & u5_5=0 & subop=0b00000 {
            #PSW.IT = 1;
            #if (!(u8_9 == 0b11)) goto <do_branch>;
            #    PSW.DT = 1;
            #<do_branch>
            local jaddr:4 = u10_14;
            set_link_gpr(lp, inst_next);
            psw_ifcon_clear();
            call [jaddr];
        }
    }
    # MISC
    with : opc=0b110010 {
        # Generate_Exception
        :BREAK   u5_19 is u20_24=0 & u5_19 & subop=0b01010 { Exception_Breakpoint(u5_19:2); }
        :SYSCALL u5_19 is u20_24=0 & u5_19 & subop=0b01011 { Exception_System_Call(u5_19:2); }
        :TRAP    u5_19 is u20_24=0 & u5_19 & subop=0b00101 { Exception_Trap(u5_19:2); }
        :TEQZ    u20_24, u5_19 is u20_24 & u5_19 & subop=0b00110 {
            if (!(u20_24 == 0)) goto <end>;
            Exception_Trap(u5_19:2);
            <end>
        }
        :TNEZ    u20_24, u5_19 is u20_24 & u5_19 & subop=0b00111 {
            if (!(u20_24 != 0)) goto <end>;
            Exception_Trap(u5_19:2);
            <end>
        }

        # covers CCTL forms from V3 as well
        :CCTL u20_24, u15_19, u5_9i, u10_10 is u20_24 & u15_19 & u11_14=0 & u10_10 & u5_9i & subop=0b00001 {
            cctl(u20_24:1, u15_19:1, u5_9i:1, u10_10:1);
        }
        :DSB is u20_24=0 & u5_19=0 & subop=0b01000 { dsb(); }
        :ISB is u20_24=0 & u5_19=0 & subop=0b01001 { isb(); }
        :ISYNC u20_24 is u20_24 & u5_19=0 & subop=0b01101 { isync(u20_24:1); }
        :IRET is u20_24=0 & u5_19=0 & subop=0b00100 { return [IPC]; }
        :MFSR u20_24, u10_19 is u20_24 & u10_19 & u5_9i=0 & subop=0b00010 { u20_24 = mfsr(u10_19:3); }
        :MTSR u20_24, u10_19 is u20_24 & u10_19 & u5_9i=0 & subop=0b00011 { mtsr(u20_24:4, u10_19:3); }
        :SETEND.^setend20 is u21_24=0 & setend20 & u10_19=0b0010000000 & u5_9i=0b00001 & subop=0b00011 { setend(setend20:1); }
        :SETGIE.^setgie20 is u21_24=0 & setgie20 & u10_19=0b0010000000 & u5_9i=0b00010 & subop=0b00011 { setgie(setgie20:1); }
        :STANDBY is u20_24=0 & u10_19=0 & u7_9=0 & standby5_6 & subop=0b00000 { standby(standby5_6:1); }
    }
    # MEM
    with : opc=0b011100 {
        addr1  : [u15_19 + (u10_14 "<<" u8_9)] is u15_19 & u10_14 & u8_9 { local addr:4 = u15_19 + (u10_14 << u8_9); export addr; }
        addr1bi: [u15_19], (u10_14 "<<" u8_9)  is u15_19 & u10_14 & u8_9 { bi_addr = u15_19 + (u10_14 << u8_9); export u15_19; }

        :DPREF dpref20_23, addr1 is u24_24=0 & dpref20_23 & addr1 & u0_7=0b00010011 unimpl

        :LB     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00000000 { u20_24 = zext(*:1 addr1); }
        :LB.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00000100 { u20_24 = zext(*:1 addr1bi); u15_19 = bi_addr; }
        :LBS    u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00010000 { u20_24 = sext(*:1 addr1); }
        :LBS.bi u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00010100 { u20_24 = sext(*:1 addr1bi); u15_19 = bi_addr; }
        :LH     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00000001 { u20_24 = zext(*:2 addr1); }
        :LH.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00000101 { u20_24 = zext(*:2 addr1bi); u15_19 = bi_addr; }
        :LHS    u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00010001 { u20_24 = sext(*:2 addr1); }
        :LHS.bi u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00010101 { u20_24 = sext(*:2 addr1bi); u15_19 = bi_addr; }
        :LW     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00000010 { u20_24 = *:4 addr1; }
        :LW.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00000110 { u20_24 = *:4 addr1bi; u15_19 = bi_addr; }
        :LLW    u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00011000 unimpl
        :LWUP   u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00100010 unimpl

        :SB     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00001000 { *:1 addr1   = u20_24:1; }
        :SB.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00001100 { *:1 addr1bi = u20_24:1; u15_19 = bi_addr; }
        :SH     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00001001 { *:2 addr1   = u20_24:2; }
        :SH.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00001101 { *:2 addr1bi = u20_24:2; u15_19 = bi_addr; }
        :SW     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00001010 { *:4 addr1   = u20_24:4; }
        :SW.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00001110 { *:4 addr1bi = u20_24:4; u15_19 = bi_addr; }
        :SCW    u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00011001 unimpl
        :SWUP   u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00101010 unimpl
    }
    # LSMW
    with : opc=0b011101 {
        # the register range is INCLUSIVE: [Rb,Re].
        # assumed that Rb <= Re
        # assumed that Rb and Re are in range [0,28)
        # Rb=Re=31 seems to mean zero-sized range
        # if zero-sized range, enable4 should be nonzero
        # i lost patience trying to do this in sleigh so it's implemented via CALLOTHER pcode injection
        # TODO maybe use autogen idea like https://github.com/xyzz/ghidra-rl78/blob/master/data/languages/rl78.slaspec.in#L149 instead of pcode injection...
        mw_wb_disp: squash reg_size disp is u10_14i & u20_24i & lmw_fp & lmw_gp & lmw_lp & lmw_sp & lmw3 [
            # squash = (u20_24i == 31) ? 0 : 1
            squash = 1 ^ (((u20_24i >> 4) & 1) & ((u20_24i >> 3) & 1) & ((u20_24i >> 2) & 1) & ((u20_24i >> 1) & 1) & (u20_24i & 1));
            reg_size = ((squash * (u10_14i - u20_24i + 1)) + lmw_fp + lmw_gp + lmw_lp + lmw_sp) * 4;
            # mul by {inc:1,dec:-1}
            disp = reg_size * (((lmw3^1) << 1) - 1);
        ] {
            export *[const]:4 disp;
        }
        :LMW.^lmw4^lmw3^lmw2 u20_24, [u15_19], u10_14, u6_9 is u20_24 & u20_24i & u15_19 & u10_14 & u10_14i & u6_9 & lmw5=0 & lmw4 & lmw3 & lmw2 & lmw2=0 & u0_1=0b00 {
            lmw(u20_24i:1, u15_19, u10_14i:1, u6_9:1, lmw4:1, lmw3:1, lmw2:1);
        }
        :LMW.^lmw4^lmw3^lmw2 u20_24, [u15_19], u10_14, u6_9 is u20_24 & u20_24i & u15_19 & u10_14 & u10_14i & u6_9 & lmw5=0 & lmw4 & lmw3 & lmw2 & lmw2=1 & u0_1=0b00 & mw_wb_disp {
            lmw(u20_24i:1, u15_19, u10_14i:1, u6_9:1, lmw4:1, lmw3:1, lmw2:1);
            build mw_wb_disp;
            u15_19 = u15_19 + mw_wb_disp;
        }
        :SMW.^lmw4^lmw3^lmw2 u20_24, [u15_19], u10_14, u6_9 is u20_24 & u20_24i & u15_19 & u10_14 & u10_14i & u6_9 & lmw5=1 & lmw4 & lmw3 & lmw2 & lmw2=0 & u0_1=0b00 {
            smw(u20_24i:1, u15_19, u10_14i:1, u6_9:1, lmw4:1, lmw3:1, lmw2:1);
        }
        :SMW.^lmw4^lmw3^lmw2 u20_24, [u15_19], u10_14, u6_9 is u20_24 & u20_24i & u15_19 & u10_14 & u10_14i & u6_9 & lmw5=1 & lmw4 & lmw3 & lmw2 & lmw2=1 & u0_1=0b00 & mw_wb_disp {
            smw(u20_24i:1, u15_19, u10_14i:1, u6_9:1, lmw4:1, lmw3:1, lmw2:1);
            build mw_wb_disp;
            u15_19 = u15_19 + mw_wb_disp;
        }
    }

    addr20  : [u15_19 + s0_14] is u15_19 & s0_14 { local addr:4 = u15_19 + s0_14; export addr; }
    addr20bi: [u15_19], s0_14  is u15_19 & s0_14 { bi_addr = u15_19 + s0_14; export u15_19; }
    # go against documentation and resolve effective immediate
    addr21  : [u15_19 + imm] is u15_19 & s0_14 [imm = s0_14 << 1;] { local addr:4 = u15_19 + imm; export addr; }
    addr21bi: [u15_19], imm  is u15_19 & s0_14 [imm = s0_14 << 1;] { bi_addr = u15_19 + imm; export u15_19; }
    addr22  : [u15_19 + imm] is u15_19 & s0_14 [imm = s0_14 << 2;] { local addr:4 = u15_19 + imm; export addr; }
    addr22bi: [u15_19], imm  is u15_19 & s0_14 [imm = s0_14 << 2;] { bi_addr = u15_19 + imm; export u15_19; }
    addr23  : [u15_19 + imm] is u15_19 & s0_14 [imm = s0_14 << 3;] { local addr:4 = u15_19 + imm; export addr; }

    :DPREFI.^dprefi24, dpref20_23, addr22 is opc=0b010011 & dprefi24 & dprefi24=0 & dpref20_23 & addr22 unimpl # w
    :DPREFI.^dprefi24, dpref20_23, addr23 is opc=0b010011 & dprefi24 & dprefi24=1 & dpref20_23 & addr23 unimpl # d

    :LBI      u20_24, addr20    is opc=0b000000 & u20_24 &          addr20   { u20_24 = zext(*:1 addr20); }
    :LBI.bi   u20_24, addr20bi  is opc=0b000100 & u20_24 & u15_19 & addr20bi { u20_24 = zext(*:1 addr20bi); u15_19 = bi_addr; }
    :LBSI     u20_24, addr20    is opc=0b010000 & u20_24 &          addr20   { u20_24 = sext(*:1 addr20); }
    :LBSI.bi  u20_24, addr20bi  is opc=0b010100 & u20_24 & u15_19 & addr20bi { u20_24 = sext(*:1 addr20bi); u15_19 = bi_addr; }
    :LHI      u20_24, addr21    is opc=0b000001 & u20_24 &          addr21   { u20_24 = zext(*:2 addr21); }
    :LHI.bi   u20_24, addr21bi  is opc=0b000101 & u20_24 & u15_19 & addr21bi { u20_24 = zext(*:2 addr21bi); u15_19 = bi_addr; }
    :LHSI     u20_24, addr21    is opc=0b010001 & u20_24 &          addr21   { u20_24 = sext(*:2 addr21); }
    :LHSI.bi  u20_24, addr21bi  is opc=0b010101 & u20_24 & u15_19 & addr21bi { u20_24 = sext(*:2 addr21bi); u15_19 = bi_addr; }
    :LWI      u20_24, addr22    is opc=0b000010 & u20_24 &          addr22   { u20_24 = *:4 addr22; }
    :LWI.bi   u20_24, addr22bi  is opc=0b000110 & u20_24 & u15_19 & addr22bi { u20_24 = *:4 addr22bi; u15_19 = bi_addr; }

    :SBI      u20_24, addr20    is opc=0b001000 & u20_24 &          addr20   { *:1 addr20   = u20_24:1; }
    :SBI.bi   u20_24, addr20bi  is opc=0b001100 & u20_24 & u15_19 & addr20bi { *:1 addr20bi = u20_24:1; u15_19 = bi_addr; }
    :SHI      u20_24, addr21    is opc=0b001001 & u20_24 &          addr21   { *:2 addr21   = u20_24:2; }
    :SHI.bi   u20_24, addr21bi  is opc=0b001101 & u20_24 & u15_19 & addr21bi { *:2 addr21bi = u20_24:2; u15_19 = bi_addr; }
    :SWI      u20_24, addr22    is opc=0b001010 & u20_24 &          addr22   { *:4 addr22   = u20_24:4; }
    :SWI.bi   u20_24, addr22bi  is opc=0b001110 & u20_24 & u15_19 & addr22bi { *:4 addr22bi = u20_24:4; u15_19 = bi_addr; }

    :ADDI  u20_24, u15_19, s0_14 is opc=0b101000 & u20_24 & u15_19 & s0_14 { u20_24 = u15_19 + s0_14; }
    :ANDI  u20_24, u15_19, u0_14 is opc=0b101010 & u20_24 & u15_19 & u0_14 { u20_24 = u15_19 & u0_14; }
    :ORI   u20_24, u15_19, u0_14 is opc=0b101100 & u20_24 & u15_19 & u0_14 { u20_24 = u15_19 | u0_14; }
    :XORI  u20_24, u15_19, u0_14 is opc=0b101011 & u20_24 & u15_19 & u0_14 { u20_24 = u15_19 ^ u0_14; }
    :SUBRI u20_24, u15_19, s0_14 is opc=0b101001 & u20_24 & u15_19 & s0_14 { u20_24 = s0_14 - u15_19; }
    :SLTI  u20_24, u15_19, s0_14 is opc=0b101110 & u20_24 & u15_19 & s0_14 { u20_24 = zext(u15_19  < s0_14); }
    :SLTSI u20_24, u15_19, s0_14 is opc=0b101111 & u20_24 & u15_19 & s0_14 { u20_24 = zext(u15_19 s< s0_14); }

    :MOVI  u20_24, s0_19 is opc=0b100010 & u20_24 & s0_19 { u20_24 = s0_19; }
    :SETHI u20_24, u0_19 is opc=0b100011 & u20_24 & u0_19 { u20_24 = u0_19 << 12; }

############# V1 perf extensions

    # ALU_2
    with : opc=0b100001 {
        :ABS   u20_24, u15_19          is u20_24 & u15_19 & u10_14=0 & u6_9=0 & subop0_5=0b000011 {
            local ra = u15_19;
            if (ra s>= 0) goto <set_val>;
            if (ra == 0x80000000) goto <set_max>;
            u20_24 = -ra;
            goto <end>;
            <set_val>
            u20_24 = ra;
            goto <end>;
            <set_max>
            u20_24 = 0x7fffffff;
            <end>
        }
        :AVE   u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14   & u6_9=0 & subop0_5=0b000010 { u20_24 = (u15_19 + u10_14) s>> 2; }
        :BCLR  u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b001001 { u20_24 = u15_19 & ~(1 << u10_14i); }
        :BSET  u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b001000 { u20_24 = u15_19 |  (1 << u10_14i); }
        :BTGL  u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b001010 { u20_24 = u15_19 ^  (1 << u10_14i); }
        :BTST  u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b001011 { u20_24 = zext((u15_19 &  (1 << u10_14i)) != 0); }
        :CLIP  u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b000101 {
            local max:4 = (1 << u10_14i) - 1;
            local min:4 = 0;
            local ra = u15_19;
            if (ra s> max) goto <set_max>;
            if (ra s< min) goto <set_zero>;
            u20_24 = ra;
            goto <end>;
            <set_max>
            u20_24 = max;
            goto <end>;
            <set_zero>
            u20_24 = 0;
            <end>
        }
        :CLIPS u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b000100 {
            local max:4 = (1 << u10_14i) - 1;
            local min:4 = -(1 << u10_14i);
            local ra = u15_19;
            if (ra s> max) goto <set_max>;
            if (ra s< min) goto <set_zero>;
            u20_24 = ra;
            goto <end>;
            <set_max>
            u20_24 = max;
            goto <end>;
            <set_zero>
            u20_24 = 0;
            <end>
        }
        :CLO   u20_24, u15_19          is u20_24 & u15_19 &           u6_14=0 & subop0_5=0b000110 { u20_24 = lzcount(~u15_19); }
        :CLZ   u20_24, u15_19          is u20_24 & u15_19 &           u6_14=0 & subop0_5=0b000111 { u20_24 = lzcount(u15_19); }
        :MAX   u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14   & u6_9=0 & subop0_5=0b000000 {
            if (u15_19 s>= u10_14) goto <set_ra>;
            u20_24 = u10_14;
            goto <end>;
            <set_ra>
            u20_24 = u15_19;
            <end>
        }
        :MIN   u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14   & u6_9=0 & subop0_5=0b000001 {
            if (u15_19 s>= u10_14) goto <set_rb>;
            u20_24 = u15_19;
            goto <end>;
            <set_rb>
            u20_24 = u10_14;
            <end>
        }
    }

############# V2 Baseline

    gprel17: [+rel] is s0_16 [rel = s0_16 << 2;] { local addr:4 = gp + rel; export addr; }
    gprel18: [+rel] is s0_17 [rel = s0_17 << 1;] { local addr:4 = gp + rel; export addr; }
    gprel19: [+s0_18] is s0_18 { local addr:4 = gp + s0_18; export addr; }

    # ALU_1
    with : opc=0b100000 {
        # TODO check div by zero and IDIVZE state
        # NOTE register order in disasm differs from instruction bitfield
        :DIVR u20_24, u5_9, u15_19, u10_14 is u20_24 & u20_24i & u15_19 & u10_14 & u5_9 & u5_9i & subop=0b10111 {
            local a:4 = u15_19;
            local b:4 = u10_14;
            u20_24 = a / b;
            # TODO dont emit pcode for this comparison, it could be constant
            if (!(u5_9i:1 != u20_24i:1)) goto <end>;
            u5_9 = a % b;
            <end>
        }
        :DIVSR u20_24, u5_9, u15_19, u10_14 is u20_24 & u20_24i & u15_19 & u10_14 & u5_9 & u5_9i & subop=0b10110 {
            local a:4 = u15_19;
            local b:4 = u10_14;
            u20_24 = a s/ b;
            if (!(u5_9i:1 != u20_24i:1)) goto <end>;
            u5_9 = a s% b;
            <end>
        }
    }
    # ALU_2
    with : opc=0b100001 {
        :MADDR32 u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & u6_9=0b0001 & subop0_5=0b110011 {
            local a:4 = u15_19;
            local b:4 = u10_14;
            local m:4 = a * b;
            u20_24 = u20_24 + m;
        }
        :MSUBR32 u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & u6_9=0b0001 & subop0_5=0b110101 {
            local a:4 = u15_19;
            local b:4 = u10_14;
            local m:4 = a * b;
            u20_24 = u20_24 - m;
        }
        :MULR64  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & u6_9=0b0001 & subop0_5=0b101001 {
            local a:8 = zext(u15_19);
            local b:8 = zext(u10_14);
            local m:8 = a * b;
            local l:4 = m:4;
            local h:4 = m(4);
            # TODO Assumes PSW.BE==0
            local rt0:4 = &u20_24 & ~3;
            local rt1:4 = rt0 + 4;
            *[register]:4 rt0 = l;
            *[register]:4 rt1 = h;
        }
        :MULSR64 u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & u6_9=0b0001 & subop0_5=0b101000 {
            local a:8 = sext(u15_19);
            local b:8 = sext(u10_14);
            local m:8 = a * b;
            local l:4 = m:4;
            local h:4 = m(4);
            # TODO Assumes PSW.BE==0
            local rt0:4 = &u20_24 & ~3;
            local rt1:4 = rt0 + 4;
            *[register]:4 rt0 = l;
            *[register]:4 rt1 = h;
        }
    }
    # LBGP
    with : opc=0b010111 {
        :LBI.gp  u20_24, gprel19 is u20_24 & u19_19=0 & gprel19 { u20_24 = zext(*:1 gprel19); }
        :LBSI.gp u20_24, gprel19 is u20_24 & u19_19=1 & gprel19 { u20_24 = sext(*:1 gprel19); }
    }
    # SBGP
    with : opc=0b011111 {
        :SBI.gp u20_24, gprel19 is u20_24 & u19_19=0 & gprel19 { *:1 gprel19 = u20_24:1; }
        :ADDI.gp u20_24, s0_18 is u20_24 & u19_19=1 & s0_18 { u20_24 = gp + s0_18; }
    }
    # HWGP
    with : opc=0b011110 {
        :LHI.gp  u20_24, gprel18 is u20_24 & hwgp18_19=0b00  & gprel18 { u20_24 = zext(*:2 gprel18); }
        :LHSI.gp u20_24, gprel18 is u20_24 & hwgp18_19=0b01  & gprel18 { u20_24 = sext(*:2 gprel18); }
        :LWI.gp  u20_24, gprel17 is u20_24 & hwgp17_19=0b110 & gprel17 { u20_24 = *:4 gprel17; }

        :SHI.gp  u20_24, gprel18 is u20_24 & hwgp18_19=0b10  & gprel18 { *:2 gprel18 = u20_24:2; }
        :SWI.gp  u20_24, gprel17 is u20_24 & hwgp17_19=0b111 & gprel17 { *:4 gprel17 = u20_24:4; }
    }

############# V3 Baseline

    # ALU_1
    with : opc=0b100000 {
        :BITC       u20_24, u15_19, u10_14        is u20_24 & u15_19 & u10_14 & u5_9i=0b00000 & subop=0b10010 { u20_24 = u15_19 & ~u10_14; }
        :ADD_SLLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b00000 { u20_24 = u15_19 + (u10_14 << u5_9i); }
        :ADD_SRLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b11100 { u20_24 = u15_19 + (u10_14 >> u5_9i); }
        :AND_SLLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b00010 { u20_24 = u15_19 & (u10_14 << u5_9i); }
        :AND_SRLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b11110 { u20_24 = u15_19 & (u10_14 >> u5_9i); }
        :OR_SLLI    u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b00100 { u20_24 = u15_19 | (u10_14 << u5_9i); }
        :OR_SRLI    u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b10101 { u20_24 = u15_19 | (u10_14 >> u5_9i); }
        :SUB_SLLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b00001 { u20_24 = u15_19 - (u10_14 << u5_9i); }
        :SUB_SRLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b11101 { u20_24 = u15_19 - (u10_14 >> u5_9i); }
        :XOR_SLLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b00011 { u20_24 = u15_19 ^ (u10_14 << u5_9i); }
        :XOR_SRLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b11111 { u20_24 = u15_19 ^ (u10_14 >> u5_9i); }
    }
    # BR3
    with : opc=0b101101 {
        imm8s_rel: rel is s0_7 [ rel = inst_start + (s0_7 << 1); ] { export *:4 rel; }
        # TODO sext(s8_18)?
        :BEQC u20_24, s8_18, imm8s_rel is u20_24 & s8_18 & imm8s_rel & u19_19=0 { branch_if(u20_24 == s8_18, imm8s_rel); }
        :BNEC u20_24, s8_18, imm8s_rel is u20_24 & s8_18 & imm8s_rel & u19_19=1 { branch_if(u20_24 != s8_18, imm8s_rel); }
    }
    # BITCI
    with : opc=0b110011 {
        # TODO zext(u0_14)?
        :BITCI u20_24, u15_19, u0_14 is u20_24 & u15_19 & u0_14 { u20_24 = u15_19 & ~u0_14; }
    }
    # JREG
    with : opc=0b100101 & u5_9=0 {
        :JRALNEZ    u20_24, u10_14  is u20_24    & u10_14 & subop=0b00011 {
            local jaddr:4 = u10_14;

            set_link_gpr(u20_24, inst_next);
            psw_ifcon_clear();

            if (!(jaddr != 0)) goto <end>;
                goto [jaddr];
            <end>
        }
        # special case for Rt=LP
        :JRALNEZ    u10_14          is u20_24=30 & u10_14 & subop=0b00011 {
            local jaddr:4 = u10_14;

            set_link_gpr(lp, inst_next);
            psw_ifcon_clear();

            if (!(jaddr != 0)) goto <end>;
                call [jaddr];
            <end>
        }
        :JRNEZ      u10_14          is u20_24=0  & u10_14 & subop=0b00010 {
            if (!(u10_14 != 0)) goto <end>;
                psw_ifcon_clear();
                goto [u10_14];
            <end>
        }
    }

############# DSP ISA Extension

    # BR2 SOP0
    with : opc=0b100111 & u16_19=0b0000 {
        :IFCALL imm16s_rel is u20_24=0b00000 & imm16s_rel {
            if (PSW.IFCON) goto <ifcon>;
                IFC_LP = inst_next;
                PSW.IFCON = 1;
            <ifcon>
            call imm16s_rel;
        }

        # ZOL Optional
        :MTLBI imm16s_rel is u20_24=0b00001 & imm16s_rel { LB = inst_start + imm16s_rel; }
        :MTLEI imm16s_rel is u20_24=0b00010 & imm16s_rel { LE = inst_start + imm16s_rel; }
    }
    # JREG
    with : opc=0b100101 {
        # haven't seen this used, but it's in binutils
        :IFRET is u20_24=0 & u15_19=0 & u5_14=0b11 & subop=0b00000 {
            if (!PSW.IFCON) goto <end>;
            psw_ifcon_clear();
            return [IFC_LP];
            <end>
        }
    }
}

with : isa_s=1 {
    # BFMI333
    with : op9_14=0b001011 {
        :XEB33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b000 { R3_6_8 = zext(R3_3_5:1); }
        :XEH33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b001 { R3_6_8 = zext(R3_3_5:2); }
        :SEB33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b010 { R3_6_8 = sext(R3_3_5:1); }
        :SEH33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b011 { R3_6_8 = sext(R3_3_5:2); }
        :XLSB33 R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b100 { R3_6_8 = R3_3_5 & 1; }
        :X11B33 R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b101 { R3_6_8 = R3_3_5 & 0x7ff; }
    }
    # XWI37
    with : op11_14=0b0111 {
        fprel: [fp + rel] is fp & imm7u [rel = imm7u << 2;] { local addr:4 = fp + rel; export addr; }
        :LWI37 R3_8_10, fprel is R3_8_10 & lwi37=0 & fprel { R3_8_10 = *:4 fprel; }
        :SWI37 R3_8_10, fprel is R3_8_10 & lwi37=1 & fprel { *:4 fprel = R3_8_10; }
    }

    addr30  : [R3_3_5, imm3u] is R3_3_5 & imm3u { local addr:4 = R3_3_5 + imm3u; export addr; }
    addr31  : [R3_3_5, imm]   is R3_3_5 & imm3u [imm = imm3u << 1;] { local addr:4 = R3_3_5 + imm; export addr; }
    addr32  : [R3_3_5, imm]   is R3_3_5 & imm3u [imm = imm3u << 2;] { local addr:4 = R3_3_5 + imm; export addr; }
    addr32bi: [R3_3_5, imm]   is R3_3_5 & imm3u [imm = imm3u << 2;] { bi_addr = R3_3_5 + imm; export R3_3_5; }

    :LBI333    R3_6_8, addr30   is op9_14=0b010011 & R3_6_8 &          addr30   { R3_6_8 = zext(*:1 addr30); }
    :LHI333    R3_6_8, addr31   is op9_14=0b010010 & R3_6_8 &          addr31   { R3_6_8 = zext(*:2 addr31); }
    :LWI333    R3_6_8, addr32   is op9_14=0b010000 & R3_6_8 &          addr32   { R3_6_8 = *:4 addr32; }
    :LWI333.bi R3_6_8, addr32bi is op9_14=0b010001 & R3_6_8 & R3_3_5 & addr32bi { R3_6_8 = *:4 addr32bi; R3_3_5 = bi_addr; }

    :SBI333    R3_6_8, addr30   is op9_14=0b010111 & R3_6_8 &          addr30   { *:1 addr30   = R3_6_8:1; }
    :SHI333    R3_6_8, addr31   is op9_14=0b010110 & R3_6_8 &          addr31   { *:2 addr31   = R3_6_8:2; }
    :SWI333    R3_6_8, addr32   is op9_14=0b010100 & R3_6_8 &          addr32   { *:4 addr32   = R3_6_8:4; }
    :SWI333.bi R3_6_8, addr32bi is op9_14=0b010101 & R3_6_8 & R3_3_5 & addr32bi { *:4 addr32bi = R3_6_8:4; R3_3_5 = bi_addr; }

    addr4: [R5_0_4] is R5_0_4 { export R5_0_4; }
    :LWI450 R4_5_8, addr4 is op9_14=0b011010 & R4_5_8 & addr4 { R4_5_8 = *:4 addr4; }
    :SWI450 R4_5_8, addr4 is op9_14=0b011011 & R4_5_8 & addr4 { *:4 addr4 = R4_5_8:4; }

    imm8s_rel: rel is imm8s [ rel = inst_start + (imm8s << 1); ] { export *:4 rel; }
    :BEQZ38 R3_8_10, imm8s_rel is op11_14=0b1000 & R3_8_10 & imm8s_rel { branch_if(R3_8_10 == 0, imm8s_rel); }
    :BNEZ38 R3_8_10, imm8s_rel is op11_14=0b1001 & R3_8_10 & imm8s_rel { branch_if(R3_8_10 != 0, imm8s_rel); }
    # if R3_8_10 == R5(a5), it's J8
    :BEQS38 R3_8_10, imm8s_rel is op11_14=0b1010 & R3_8_10 & imm8s_rel { branch_if(R3_8_10 == a5, imm8s_rel); }
    :BNES38 R3_8_10, imm8s_rel is op11_14=0b1011 & R3_8_10 & imm8s_rel { branch_if(R3_8_10 != a5, imm8s_rel); }
    :BEQZS8 imm8s_rel is op8_14=0b1101000 & imm8s_rel { branch_if(ta == 0, imm8s_rel); }
    :BNEZS8 imm8s_rel is op8_14=0b1101001 & imm8s_rel { branch_if(ta != 0, imm8s_rel); }

    # V3 ISA modifies BREAK16 such that imm4u is zero. nonzero imm4u encodes EX9.IT instead.
    :BREAK16 imm5u is op9_14=0b110101 & imm4u=0 & imm5u { Exception_Breakpoint(imm5u:1); }

    :J8 imm8s_rel is op8_14=0b1010101 & imm8s_rel { psw_ifcon_clear(); goto imm8s_rel; }
    :JR5   R5_0_4 is op5_14=0b1011101000 & R5_0_4 { psw_ifcon_clear(); goto [R5_0_4]; }
    :JRAL5 R5_0_4 is op5_14=0b1011101001 & R5_0_4 { set_link_gpr(lp, inst_next); psw_ifcon_clear(); call [R5_0_4]; }

    :RET5 R5_0_4 is op5_14=0b1011101100 & R5_0_4 { return [R5_0_4]; }

    :MOV55  R5_5_9, R5_0_4 is op10_14=0b00000 & R5_5_9 & R5_0_4 { R5_5_9 = R5_0_4; }
    :MOVI55 R5_5_9, imm5s  is op10_14=0b00001 & R5_5_9 & imm5s { R5_5_9 = imm5s; }

    # special case of SRLI45 R0,0
    :NOP16 is op9_14=0b001001 & R4_5_8=0 & R5_0_4=0 {}

    :ADD333 R3_6_8, R3_3_5, R3_0_2 is op9_14=0b001100 & R3_6_8 & R3_3_5 & R3_0_2 { R3_6_8 = R3_3_5 + R3_0_2; }
    :SUB333 R3_6_8, R3_3_5, R3_0_2 is op9_14=0b001101 & R3_6_8 & R3_3_5 & R3_0_2 { R3_6_8 = R3_3_5 - R3_0_2; }

    :ADDI333 R3_6_8, R3_3_5, imm3u is op9_14=0b001110 & R3_6_8 & R3_3_5 & imm3u { R3_6_8 = R3_3_5 + imm3u; }
    :SLLI333 R3_6_8, R3_3_5, imm3u is op9_14=0b001010 & R3_6_8 & R3_3_5 & imm3u { R3_6_8 = R3_3_5 << imm3u; }
    :SUBI333 R3_6_8, R3_3_5, imm3u is op9_14=0b001111 & R3_6_8 & R3_3_5 & imm3u { R3_6_8 = R3_3_5 - imm3u; }

    :ADD45   R4_5_8, R5_0_4 is op9_14=0b000100 & R4_5_8 & R5_0_4 { R4_5_8 = R4_5_8 + R5_0_4; }
    :SLT45   R4_5_8, R5_0_4 is op9_14=0b110001 & R4_5_8 & R5_0_4 { ta = zext(R4_5_8 < R5_0_4); }
    :SLTS45  R4_5_8, R5_0_4 is op9_14=0b110000 & R4_5_8 & R5_0_4 { ta = zext(R4_5_8 s< R5_0_4); }
    :SUB45   R4_5_8, R5_0_4 is op9_14=0b000101 & R4_5_8 & R5_0_4 { R4_5_8 = R4_5_8 - R5_0_4; }

    :ADDI45  R4_5_8, imm5u is op9_14=0b000110 & R4_5_8 & imm5u { R4_5_8 = R4_5_8 + imm5u; }
    :SLTI45  R4_5_8, imm5u is op9_14=0b110011 & R4_5_8 & imm5u { ta = zext(R4_5_8 < imm5u); }
    :SLTSI45 R4_5_8, imm5u is op9_14=0b110010 & R4_5_8 & imm5u { ta = zext(R4_5_8 s< imm5u); }
    :SRAI45  R4_5_8, imm5u is op9_14=0b001000 & R4_5_8 & imm5u { R4_5_8 = R4_5_8 s>> imm5u; }
    :SRLI45  R4_5_8, imm5u is op9_14=0b001001 & R4_5_8 & imm5u { R4_5_8 = R4_5_8 >> imm5u; }
    :SUBI45  R4_5_8, imm5u is op9_14=0b000111 & R4_5_8 & imm5u { R4_5_8 = R4_5_8 - imm5u; }

########## V2 Baseline
    # XWI37SP
    with : op11_14=0b1110 {
        sprel: [+rel] is imm7u [rel = imm7u << 2;] { local addr:4 = sp + rel; export addr; }
        :LWI37.sp R3_8_10, sprel is R3_8_10 & lwi37=0 & sprel { R3_8_10 = *:4 sprel; }
        :SWI37.sp R3_8_10, sprel is R3_8_10 & lwi37=1 & sprel { *:4 sprel = R3_8_10:4; }
    }
    :ADDI10.sp imm10s is op10_14=0b11011 & imm10s { sp = sp + imm10s; }

########## V3 Baseline
    imm8u_5: imm is imm5u [imm = imm5u << 3;] { export *[const]:4 imm; }
    imm8u_6: imm is imm6u [imm = imm6u << 2;] { export *[const]:4 imm; }

    :ADDRI36.sp R3_6_8, imm8u_6 is op9_14=0b011000 & R3_6_8 & imm8u_6 { R3_6_8 = sp + imm8u_6; }
    :ADD5.pc R5_0_4 is op5_14=0b1011101101 & R5_0_4 { R5_0_4 = inst_start + R5_0_4; }
    # MISC33
    with : op9_14=0b111111 {
        :AND33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b110 { R3_6_8 = R3_6_8 & R3_3_5; }
        :MUL33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b100 { R3_6_8 = R3_6_8 * R3_3_5; }
        :NEG33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b010 { R3_6_8 = -R3_3_5; }
        :NOT33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b011 { R3_6_8 = ~R3_3_5; }
        :OR33   R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b111 { R3_6_8 = R3_6_8 | R3_3_5; }
        :XOR33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b101 { R3_6_8 = R3_6_8 ^ R3_3_5; }
    }
    # BFMI333
    with : op9_14=0b001011 {
        :BMSKI33 R3_6_8, imm3u is R3_6_8 & imm3u & subop0_2=0b110 { R3_6_8 = R3_6_8 & (1 << imm3u); }
        :FEXTI33 R3_6_8, imm3u is R3_6_8 & imm3u & subop0_2=0b111 { R3_6_8 = R3_6_8 & ((1 << (imm3u + 1)) - 1); }
    }
    # TODO sext?
    imm7n: imm is imm5u [imm = (imm5u - 32) << 2;] { export *[const]:4 imm; }
    :LWI45.FE R4_5_8, [imm7n] is op9_14=0b011001 & R4_5_8 & imm7n {
        R4_5_8 = *:4 (s2 + imm7n);
    }
    :MOVD44 R4_4_7, R4_0_3 is op8_14=0b1111101 & R4_4_7 & R4_0_3 {
        local rt1:4 = &R4_4_7;
        local rt2:4 = rt1 + 4;
        local ra1:4 = &R4_0_3;
        local ra2:4 = ra1 + 4;
        *[register]:4 rt1 = *[register]:4 ra1;
        *[register]:4 rt2 = *[register]:4 ra2;
    }
    imm6u_5: imm is imm5u [imm = imm5u + 16;] { export *[const]:4 imm; }
    :MOVPI45 R4_5_8, imm6u_5  is op9_14=0b111101 & R4_5_8 & imm6u_5 { R4_5_8 = imm6u_5; }

    # Specialize all forms of PUSH25/POP25. there's only 4 cases each...
    # show arm-like register list (deviates from assembler spec / should probably change so ghidra UI highlights regs properly)
    # XXX the processor writes registers to memory in ascending order. This impl descends to simplify logic.
    macro push_reg(ri) {
        sp = sp - 4;
        *:4 sp = ri;
    }
    macro push25_prologue() {
        push_reg(lp);
        push_reg(gp);
        push_reg(fp);
    }
    macro push25_epilog_0(imm8u_5) {
        push_reg(s0);
        sp = sp - imm8u_5;
    }
    macro push25_epilog_2(imm8u_5) {
        push_reg(s2);
        push_reg(s1);
        push25_epilog_0(imm8u_5);
        # store function entry point in r8
        # only implicitly used by LWI45.FE
        # NOT done for Re == 0
        s2 = inst_start & ~0b11;
    }
    macro push25_epilog_4(imm8u_5) {
        push_reg(s4);
        push_reg(s3);
        push25_epilog_2(imm8u_5);
    }
    macro push25_epilog_8(imm8u_5) {
        push_reg(s8);
        push_reg(s7);
        push_reg(s6);
        push_reg(s5);
        push25_epilog_4(imm8u_5);
    }
    :PUSH25 "{s0,fp,gp,lp}", imm8u_5    is op7_14=0b11111000 & R2_5_6=0b00 & imm8u_5 {
        push25_prologue();
        push25_epilog_0(imm8u_5);
    }
    :PUSH25 "{s0-s2,fp,gp,lp}", imm8u_5 is op7_14=0b11111000 & R2_5_6=0b01 & imm8u_5 {
        push25_prologue();
        push25_epilog_2(imm8u_5);
    }
    :PUSH25 "{s0-s4,fp,gp,lp}", imm8u_5 is op7_14=0b11111000 & R2_5_6=0b10 & imm8u_5 {
        push25_prologue();
        push25_epilog_4(imm8u_5);
    }
    :PUSH25 "{s0-s8,fp,gp,lp}", imm8u_5 is op7_14=0b11111000 & R2_5_6=0b11 & imm8u_5 {
        push25_prologue();
        push25_epilog_8(imm8u_5);
    }
    macro pop_reg(ri) {
        ri = *:4 sp;
        sp = sp + 4;
    }
    macro pop25_prologue_0() {
        pop_reg(s0);
    }
    macro pop25_prologue_2() {
        pop25_prologue_0();
        pop_reg(s1);
        pop_reg(s2);
    }
    macro pop25_prologue_4() {
        pop25_prologue_2();
        pop_reg(s3);
        pop_reg(s4);
    }
    macro pop25_prologue_8() {
        pop25_prologue_4();
        pop_reg(s5);
        pop_reg(s6);
        pop_reg(s7);
        pop_reg(s8);
    }
    macro pop25_epilogue() {
        pop_reg(fp);
        pop_reg(gp);
        pop_reg(lp);
        psw_ifcon_clear();
        return [lp];
    }
    :POP25  "{s0,fp,gp,lp}", imm8u_5    is op7_14=0b11111001 & R2_5_6=0b00 & imm8u_5 {
        sp = sp + imm8u_5;
        pop25_prologue_0();
        pop25_epilogue();
    }
    :POP25  "{s0-s2,fp,gp,lp}", imm8u_5 is op7_14=0b11111001 & R2_5_6=0b01 & imm8u_5 {
        sp = sp + imm8u_5;
        pop25_prologue_2();
        pop25_epilogue();
    }
    :POP25  "{s0-s4,fp,gp,lp}", imm8u_5 is op7_14=0b11111001 & R2_5_6=0b10 & imm8u_5 {
        sp = sp + imm8u_5;
        pop25_prologue_4();
        pop25_epilogue();
    }
    :POP25  "{s0-s8,fp,gp,lp}", imm8u_5 is op7_14=0b11111001 & R2_5_6=0b11 & imm8u_5 {
        sp = sp + imm8u_5;
        pop25_prologue_8();
        pop25_epilogue();
    }

########## EX9IT Extension

    # indirect instruction execution from Instruction_Table
    :EX9.IT imm9u is op9_14=0b110101 & imm9u     { ex9it(imm9u:2); }
    :EX9.IT imm5u is op5_14=0b1011101010 & imm5u { ex9it(imm5u:1); }

########## DSP ISA Extension

    # TODO flow analysis gets screwed up by IFCALL/IFRET
    imm9s_rel: rel is imm9s [ rel = inst_start + (imm9s << 1); ] { export *:4 rel; }
    :IFCALL9 imm9s_rel is op10_14=0b11110 & imm9s_rel {
        if (PSW.IFCON) goto <ifcon>;
            IFC_LP = inst_next;
            PSW.IFCON = 1;
        <ifcon>
        call imm9s_rel;
    }
    # Special case of MOV55 encoding (Rt=sp, Ra=sp)
    :IFRET16 is op10_14=0b00000 & R5_5_9=0b11111 & R5_0_4=0b11111 {
        if (!PSW.IFCON) goto inst_next;
        psw_ifcon_clear();
        return [IFC_LP];
    }
}
