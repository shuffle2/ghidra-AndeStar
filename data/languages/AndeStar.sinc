# instruction endianness is always big, but data load/store endian is controlled by PSW.BE
# PSW.BE reset value is implementation defined, so it is useful to provide language specs defaulting each way
define endian=$(ENDIAN);
define alignment=2;

define space ram        type=ram_space      size=4 default;
define space register   type=register_space size=4;

# GPRs
define register offset=0 size=4 [
    a0 a1 a2 a3 a4 a5
    s0 s1 s2 s3 s4 s5 s6 s7 s8
    ta
    t0 t1 t2 t3 t4 t5 t6 t7 t8 t9
    p0 p1
    fp gp lp sp
];

# USRs (User Special Registers)
define register offset=0x80 size=8 [d0 d1];
define register offset=0x80 size=4 [
    # Group 0
    d0.hi d0.lo d1.hi d1.lo
    LB LE LC
    ITB IFC_LP PC

    # Group 1,2 are views into SRs
];

# SR Encoding is 10bits. 3 Major, 4 Minor, 3 Extension
# PSW = ir0 (1, 0, 0)
# IPC = ir9 (1, 0, 1)
define register offset=0x100 size=4 [
  # Major 0: Configuration
  CPU_VER ICM_CFG DCM_CFG MMU_CFG MSC_CFG MSC_CFG2 CORE_ID FUCOP_EXIST

  # Major 1: Interruption
  PSW IPSW P_IPSW IVB EVA P_EVA ITYPE P_ITYPE MERR IPC P_IPC OIPC
  P_P0 P_P1 INT_MASK INT_PEND SP_USR SP_PRIV INT_PRI INT_CTRL
  INT_MASK2 INT_PEND2 INT_PRI2 INT_TRIGGER

  # Major 2: MMU
  MMU_CTL L1_PPTB TLB_VPN TLB_DATA TLB_MISC VLPT_IDX ILMB DLMB CACHE_CTL HSMP_SADDR

  # Major 2, Minor 15: Implementation-Dependent
  SDZ_CTL MISC_CTL ECC_MISC

  # Major 3: Embedded Debug Mode
  BPC0 BPC1 BPC2 BPC3 BPC4 BPC5 BPC6 BPC7
  BPA0 BPA1 BPA2 BPA3 BPA4 BPA5 BPA6 BPA7
  BPAM0 BPAM1 BPAM2 BPAM3 BPAM4 BPAM5 BPAM6 BPAM7
  BPV0 BPV1 BPV2 BPV3 BPV4 BPV5 BPV6 BPV7
  BPCID0 BPCID1 BPCID2 BPCID3 BPCID4 BPCID5 BPCID6 BPCID7
  EDM_CFG EDMSW EDM_CTL EDM_DTR BPMTC DIMBR TECR0 TECR1

  # Major 4: Performance Monitoring
  PFMC0 PFMC1 PFMC2
  PFM_CTL PFT_CTL

  # Major 4, Minor 4,5: Resource Access Control
  PRUSR_ACC_CTL FUCOP_CTL

  # Major 4, Minor 6: Hardware Stack Protection
  HSP_CTL SP_BOUND SP_BOUND_PRIV SP_BASE SP_BASE_PRIV

  # Major 5: Local Memory DMA
  DMA_CFG DMA_GCSW DMA_CHNSEL DMA_ACT DMA_SETUP DMA_ISADDR DMA_ESADDR DMA_TCNT
  DMA_STATUS DMA_2DSET DMA_2DSCTL DMA_RCNT DMA_HSTATUS
];
# seen SRs
# 0x008  (0, 1, 0)    ICM_CFG
# 0x010  (0, 2, 0)    DCM_CFG
# 0x080  (1, 0, 0)    PSW
# 0x081  (1, 0, 1)    IPSW
# 0x089  (1, 1, 1)    IVB
# 0x091  (1, 2, 1)    EVA
# 0x099  (1, 3, 1)    ITYPE
# 0x0a9  (1, 5, 1)    IPC
# 0x0c0  (1, 8, 0)    INT_MASK
# 0x100  (2, 0, 0)    MMU_CTL
# 0x138  (2, 7, 0)    DLMB
# 0x140  (2, 8, 0)    CACHE_CTL
# 0x178  (2, 15, 0)   SDZ_CTL
# 0x179  (2, 15, 1)   MISC_CTL
# 0x200  (4, 0, 0)    PFMC0
# 0x201  (4, 0, 1)    PFMC1
# 0x202  (4, 0, 2)    PFMC2
# 0x208  (4, 1, 0)    PFM_CTL

# NOTE other languages use @defines instead of bitrange - why?
define bitrange
    PSW.GIE     =PSW[0,1]
    PSW.INTL    =PSW[1,2]
    PSW.POM     =PSW[3,2]
    PSW.BE      =PSW[5,1]
    PSW.IT      =PSW[6,1]
    PSW.DT      =PSW[7,1]
    PSW.IME     =PSW[8,1]
    PSW.DME     =PSW[9,1]
    PSW.DEX     =PSW[10,1]
    PSW.HSS     =PSW[11,1]
    PSW.DRBE    =PSW[12,1]
    PSW.AEN     =PSW[13,1]
    PSW.WBNA    =PSW[14,1]
    PSW.IFCON   =PSW[15,1]
    PSW.CPL     =PSW[16,2]
    PSW.OV      =PSW[20,1]
    PSW.PFT_EN  =PSW[21,1]
    PSW.PNP     =PSW[22,1];

#@define PSW.GIE     "PSW[0,1]"
#@define PSW.INTL    "PSW[1,2]"
#@define PSW.POM     "PSW[3,2]"
#@define PSW.BE      "PSW[5,1]"
#@define PSW.IT      "PSW[6,1]"
#@define PSW.DT      "PSW[7,1]"
#@define PSW.IME     "PSW[8,1]"
#@define PSW.DME     "PSW[9,1]"
#@define PSW.DEX     "PSW[10,1]"
#@define PSW.HSS     "PSW[11,1]"
#@define PSW.DRBE    "PSW[12,1]"
#@define PSW.AEN     "PSW[13,1]"
#@define PSW.WBNA    "PSW[14,1]"
#@define PSW.IFCON   "PSW[15,1]"
#@define PSW.CPL     "PSW[16,2]"
#@define PSW.OV      "PSW[20,1]"
#@define PSW.PFT_EN  "PSW[21,1]"
#@define PSW.PNP     "PSW[22,1]"

# ghidra state
define register offset=0x1000 size=4 [mult_addr bi_addr IFC_ON];

# valid if isa=0
define token instr32(32) endian=big
    isa         = (31,31)
    opc         = (25,30)
    subop       = (0,4)
    subop0_5    = (0,5)
    subop0_6    = (0,6)

    dthi21 = (21,21)
    dtlo21 = (21,21)
    dt21 = (21,21)

    hwgp18_19=(18,19)
    hwgp17_19=(17,19)

    u6_9 = (6,9)
    lmw_fp=(9,9)
    lmw_gp=(8,8)
    lmw_lp=(7,7)
    lmw_sp=(6,6)
    lmw5 = (5,5)
    lmw4 = (4,4)
    lmw3=(3,3)
    lmw2=(2,2)
    u0_1=(0,1)

    setend20=(20,20)
    setgie20=(20,20)

    dprefi24=(24,24)
    dpref20_23=(20,23)

    standby5_6=(5,6)

    u22_24=(22,24)
    u21_24=(21,24)
    u20_20=(20,20)
    u7_14=(7,14)
    u6_14=(6,14)

    u24_24  = (24,24)
    u20_24  = (20,24)
    u20_24i = (20,24)
    u19_19  = (19,19)
    u15_24  = (15,24)
    u20_23  = (20,23)
    u16_19  = (16,19)
    u15_19  = (15,19)
    u15_19i = (15,19)
    u5_19   =  (5,19)
    u5_14   =  (5,14)
    u14_14  = (14,14)
    u11_14  = (11,14)
    u10_19  = (10,19)
    u10_14  = (10,14)
    u10_14i = (10,14)
    u10_10  = (10,10)
    s8_18   =  (8,18) signed
    u0_19   =  (0,19)
    s0_19   =  (0,19) signed
    u0_14   =  (0,14)
    s0_23   =  (0,23) signed
    s0_18   =  (0,18) signed
    s0_17   =  (0,17) signed
    s0_16   =  (0,16) signed
    s0_15   =  (0,15) signed
    s0_14   =  (0,14) signed
    s0_13   =  (0,13) signed
    u8_9    =   (8,9)
    u7_9    =   (7,9)
    u5_9    =   (5,9)
    u5_9i   =   (5,9)
    u6_7    =   (6,7)
    s0_7    =   (0,7) signed
    u0_7    =   (0,7)
    u0_5    =   (0,5)
    u5_7    =   (5,7)
    u5_5    =   (5,5)

    OpSz=(31,31)
    Opc=(25,30)
    Rt          = (20, 24)
    Rth         = (21, 24)
    Rtl         = (21, 24)
    Ra          = (15, 19)
    Rb          = (10, 14)
    Rd          = (5, 9)
    Rs          = (5, 9)
    Sub5        = (0, 4)
    Sub6        = (0, 5)
    Sub8        = (0, 7)

    Alu2Mod     = (6, 9)

    MsyncZ      = (8, 19)
    MsyncSub    = (5, 7)

    SrMaj=(17,19)
    SrMin=(13,16)
    SrExt=(10,12)

    TlbopSub    = (5, 9)

    LsmwRa = (15, 19)
    LsmwRb = (20, 24)
    LsmwRe = (10, 14)
    Enable4 = (6, 9)
    Enable4_fp = (9, 9)
    Enable4_gp = (8, 8)
    Enable4_lp = (7, 7)
    Enable4_sp = (6, 6)
    LsmwLs = (5, 5)
    LsmwBa = (4, 4)
    LsmwId = (3, 3)
    LsmwM = (2, 2)
    LsmwSub = (0, 1)
;

# valid if isa_s=1
define token instr16(16) endian=big
    isa_s = (15,15)

    op11_14 = (11,14)
    op10_14 = (10,14)
    op9_14 = (9,14)
    op8_14 = (8,14)
    op7_14 = (7,14)
    op5_14 = (5,14)
    subop0_2 = (0,2)

    R5_5_9 = (5,9)
    R5_0_4 = (0,4)

    R4_5_8 = (5,8)
    R4_4_7 = (4,7)
    R4_0_3 = (0,3)

    R3_8_10 = (8,10)
    R3_6_8 = (6,8)
    R3_3_5 = (3,5)
    R3_0_2 = (0,2)

    R2_5_6 = (5,6)

    imm4u = (5,8)

    imm9u = (0,8)
    imm9s = (0,8) signed
    imm10s = (0,9) signed
    imm8s = (0,7) signed
    imm7u = (0,6)
    imm6u = (0,5)
    imm5u = (0,4)
    imm5s = (0,4) signed
    imm3u = (0,2)

    lwi37 = (7,7)

    opsz        = (15, 15)
    opc4        = (11, 14)
    opc6        = (9, 14)
;

# GPRs - 32/16bit instructions, 5bit index
attach variables [
    u20_24 u15_19 u10_14 u5_9
    R5_5_9 R5_0_4
    Rt Rs Ra Rb Rd
    LsmwRa LsmwRb LsmwRe
] [
    a0 a1 a2 a3 a4 a5
    s0 s1 s2 s3 s4 s5 s6 s7 s8
    ta
    t0 t1 t2 t3 t4 t5 t6 t7 t8 t9
    p0 p1
    fp gp lp sp
];
# GPRs - 16bit instruction, 4bit index
attach variables [R4_5_8] [
    a0 a1 a2 a3 a4 a5
    s0 s1 s2 s3 s4 s5
    t0 t1 t2 t3
];
# GPRs - 16bit instruction, 3bit index
attach variables [R3_0_2 R3_3_5 R3_6_8 R3_8_10] [
    a0 a1 a2 a3 a4 a5
    s0 s1
];
attach variables [R2_5_6] [
    s0 s2 s4 s8
];
# These fields index even registers
attach variables [R4_0_3 R4_4_7] [
    a0 a2 a4
    s0 s2 s4 s6 s8
    t0 t2 t4 t6 t8
    p0
    fp lp
];

# USRs
attach variables [dtlo21] [d0.lo d1.lo];
attach variables [dthi21] [d0.hi d1.hi];
attach variables [dt21] [d0 d1];

attach names [setend20] [L B];
attach names [setgie20] [D E];
attach names [dprefi24] [w d];
attach names [dpref20_23] [
    SRD MRD SWR MWR PTE CLWR
    ImpDep6 ImpDep7 ImpDep8 ImpDep9 ImpDep10
    ImpDep11 ImpDep12 ImpDep13 ImpDep14 ImpDep15
];
attach names [standby5_6] [no_wake_grant wake_grant wait_done reserved];
attach names [lmw2] ["" m];
attach names [lmw3] [i d];
attach names [lmw4] [b a];

define pcodeop Exception_Breakpoint;
define pcodeop Exception_System_Call;
define pcodeop Exception_Trap;
define pcodeop cctl;
define pcodeop dsb;
define pcodeop isb;
define pcodeop msync;
define pcodeop isync;
define pcodeop mfsr;
define pcodeop mtsr;
define pcodeop setend;
define pcodeop setgie;
define pcodeop standby;
define pcodeop ex9it;

# for now, IFC_ON is dedicated register to make pcode more simple.
# wrong behavior, but only matters for things exposing r/w access to PSW directly.
macro psw_ifcon_clear() {
    IFC_ON = 0;
}

macro branch_if(cond, target) {
    if (!cond) goto inst_next;
    psw_ifcon_clear();
    goto target;
}

macro call_if(cond, target) {
    if (!cond) goto inst_next;
    psw_ifcon_clear();
    call target;
}

macro ifcall(target) {
    if (IFC_ON == 1) goto <ifcon>;
        IFC_LP = inst_next;
    <ifcon>
    IFC_ON = 1;
    call target;
}

macro ifret() {
    if (IFC_ON == 0) goto inst_next;
    psw_ifcon_clear();
    return [IFC_LP];
}

# NOTE if decompiler only sees IFC_ON as single value on all flows to this pcode block, it will warn about unreachable code elimination
# not sure there's much to do about it
macro set_link_gpr(gpr, target) {
    if (IFC_ON == 1) goto <ifcon>;
        gpr = target;
        goto <fi>;
    <ifcon>
        gpr = IFC_LP;
    <fi>
}

@define I32     "(OpSz=0)"
@define ALU_1   "(Opc=0b100000)"
@define ALU_2   "(Opc=0b100001)"
@define ALU2Z   "(Alu2Mod=0b0000)"
@define GPR     "(Alu2Mod=0b0001)"
@define BR1     "(Opc=0b100110)"
@define BR2     "(Opc=0b100111)"
@define BR3     "(Opc=0b101101)"
@define LSMW    "(Opc=0b011101)"
@define JI      "(Opc=0b100100)"
@define MEM     "(Opc=0b011100)"
@define MISC    "(Opc=0b110010)"
@define BITCI   "(Opc=0b110011)"
@define JREG    "(Opc=0b100101)"
@define SBGP    "(Opc=0b011111)"
@define LBGP    "(Opc=0b010111)"
@define HWGP    "(Opc=0b011110)"
@define SIMD    "(Opc=0b111000)"

@include "lsmw.sinc"

with : $(I32) {
    with : $(ALU_1) & u5_9i=0 {
        :ADD   u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00000 { u20_24 =   u15_19 + u10_14; }
        :AND   u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00010 { u20_24 =   u15_19 & u10_14; }
        :OR    u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00100 { u20_24 =   u15_19 | u10_14; }
        :XOR   u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00011 { u20_24 =   u15_19 ^ u10_14; }
        :NOR   u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00101 { u20_24 = ~(u15_19 | u10_14); }
        :ROTR  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b01111 {
            local ra = u10_14[0,5];
            u20_24 = (u15_19 >> ra) | (u15_19 << (32 - ra));
        }
        :ROTRI u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i & subop=0b01011 {
            local ra = u10_14i;
            u20_24 = (u15_19 >> ra) | (u15_19 << (32 - ra));
        }
        :CMOVN u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b11011 {
            if (!(u10_14 != 0)) goto inst_next;
            u20_24 = u15_19;
        }
        :CMOVZ u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b11010 {
            if (!(u10_14 == 0)) goto inst_next;
            u20_24 = u15_19;
        }
        :SEB u20_24, u15_19 is u20_24 & u15_19 & u5_14=0 & subop=0b10000 { u20_24 = sext(u15_19:1); }
        :SEH u20_24, u15_19 is u20_24 & u15_19 & u5_14=0 & subop=0b10001 { u20_24 = sext(u15_19:2); }
        :ZEH u20_24, u15_19 is u20_24 & u15_19 & u5_14=0 & subop=0b10011 { u20_24 = zext(u15_19:2); }

        :SLL  u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14  & subop=0b01100 { u20_24 = u15_19 << u10_14[0,5]; }
        :SLLI u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i & subop=0b01000 {
            local sa:4 = u10_14i;
            u20_24 = u15_19 << sa[0,5];
        }
        :SRA  u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14  & subop=0b01110 { u20_24 = u15_19 s>> u10_14[0,5]; }
        :SRAI u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i & subop=0b01010 {
            local sa:4 = u10_14i;
            u20_24 = u15_19 s>> sa[0,5];
        }
        :SRL  u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14  & subop=0b01101 { u20_24 = u15_19 >> u10_14[0,5]; }
        :SRLI u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i & subop=0b01001 {
            local sa:4 = u10_14i;
            u20_24 = u15_19 >> sa[0,5];
        }
        :NOP is u20_24=0 & u15_19=0 & u10_14=0 & subop=0b01001 {}

        :SLT  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00110 { u20_24 = zext(u15_19  < u10_14); }
        :SLTS u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00111 { u20_24 = zext(u15_19 s< u10_14); }

        :SUB  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b00001 { u20_24 = u15_19 - u10_14; }
        :SVA  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b11000 { u20_24 = zext(scarry(u15_19, u10_14)); }
        :SVS  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & subop=0b11001 { u20_24 = zext(sborrow(u15_19, u10_14)); }
        :WSBH u20_24, u15_19 is u20_24 & u15_19 & u10_14=0 & subop=0b10100 {
            u20_24 =
                ((u15_19 & 0x000000ff) << 8) |
                ((u15_19 & 0x0000ff00) >> 8) |
                ((u15_19 & 0x00ff0000) << 8) |
                ((u15_19 & 0xff000000) >> 8);
        }
    }
    with : $(ALU_2) {
        :BTST u20_24, u15_19, u0_5 is u20_24 & u15_19 & u0_5 & subop0_5=0b001011 {
            u20_24 = zext((u15_19 & (1 << u0_5)) != 0);
        }

        :MUL u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & u6_9=0 & subop0_5=0b100100 { u20_24 = u15_19 * u10_14; }
        :MULTS64 dt21,    u15_19, u10_14 is u22_24=0 & dt21    & u20_20=0 & u15_19 & u10_14 & $(ALU2Z) & subop0_5=0b101000 { dt21 = sext(u15_19) * sext(u10_14); }
        :MULT64  dt21,    u15_19, u10_14 is u22_24=0 & dt21    & u20_20=0 & u15_19 & u10_14 & $(ALU2Z) & subop0_5=0b101001 { dt21 = zext(u15_19) * zext(u10_14); }
        :MADDS64 dt21, u15_19, u10_14   is u22_24=0 & dt21   & u20_20=0 & u15_19 & u10_14 & u6_9=0 & subop0_5=0b101010 {
            local a:8 = sext(u15_19);
            local b:8 = sext(u10_14);
            local m:8 = a * b;
            dt21 = dt21 + m;
        }
        :MADD64 dt21, u15_19, u10_14    is u22_24=0 & dt21   & u20_20=0 & u15_19 & u10_14 & u6_9=0 & subop0_5=0b101011 {
            local a:8 = zext(u15_19);
            local b:8 = zext(u10_14);
            local m:8 = a * b;
            dt21 = dt21 + m;
        }
        :MSUBS64 dt21,    u15_19, u10_14 is u22_24=0 & dt21    & u20_20=0 & u15_19 & u10_14 & $(ALU2Z) & subop0_5=0b101100 { dt21 = dt21 - (sext(u15_19) * sext(u10_14)); }
        :MSUB64  dt21,    u15_19, u10_14 is u22_24=0 & dt21    & u20_20=0 & u15_19 & u10_14 & $(ALU2Z) & subop0_5=0b101101 { dt21 = dt21 - (zext(u15_19) * zext(u10_14)); }
        :MULT32  dtlo21, u15_19, u10_14 is u22_24=0 & dtlo21 & u20_20=0 & u15_19 & u10_14 & $(ALU2Z) & subop0_5=0b110001 { dtlo21 = u15_19 * u10_14; }
        :MADD32 dtlo21, u15_19, u10_14  is u22_24=0 & dtlo21 & u20_20=0 & u15_19 & u10_14 & u6_9=0 & subop0_5=0b110011 {
            local a = u15_19;
            local b = u10_14;
            local m = a * b;
            dtlo21 = dtlo21 + m;
        }
        :MSUB32  dtlo21, u15_19, u10_14 is u22_24=0 & dtlo21 & u20_20=0 & u15_19 & u10_14 & $(ALU2Z) & subop0_5=0b110101 { dtlo21 = dtlo21 - (u15_19 * u10_14); }

        :DIV  dt21, Ra, Rb is u22_24=0 & dt21 & dtlo21 & dthi21 & u20_20=0 & Ra & Rb & $(ALU2Z) & Sub6=0b101111 {
            dtlo21 = Ra  / Rb;
            dthi21 = Ra  % Rb;
        }
        :DIVS dt21, Ra, Rb is u22_24=0 & dt21 & dtlo21 & dthi21 & u20_20=0 & Ra & Rb & $(ALU2Z) & Sub6=0b101110 {
            dtlo21 = Ra s/ Rb;
            dthi21 = Ra s% Rb;
        }

        with : u10_14i=0 {
          USR_Name: d0.hi   is d0.hi  & u15_19i=0 { export d0.hi; }
          USR_Name: d0.lo   is d0.lo  & u15_19i=1 { export d0.lo; }
          USR_Name: d1.hi   is d1.hi  & u15_19i=2 { export d1.hi; }
          USR_Name: d1.lo   is d1.lo  & u15_19i=3 { export d1.lo; }
          # ZOL Extension (DSP)
          USR_Name: LB      is LB     & u15_19i=25 { export LB; }
          USR_Name: LE      is LE     & u15_19i=26 { export LE; }
          USR_Name: LC      is LC     & u15_19i=27 { export LC; }
          # EX9.IT Extension
          USR_Name: ITB     is ITB    & u15_19i=28 { export ITB; }
          # IFC Extension (DSP)
          USR_Name: IFC_LP  is IFC_LP & u15_19i=29 { export IFC_LP; }
          USR_Name: PC      is PC     & u15_19i=31 { export PC; }
        }
        with : u10_14i=1 {
          USR_Name: DMA_CFG     is DMA_CFG    & u15_19i=0 { export DMA_CFG; }
          USR_Name: DMA_GCSW    is DMA_GCSW   & u15_19i=1 { export DMA_GCSW; }
          USR_Name: DMA_CHNSEL  is DMA_CHNSEL & u15_19i=2 { export DMA_CHNSEL; }
          USR_Name: DMA_ACT     is DMA_ACT    & u15_19i=3 { export DMA_ACT; }
          USR_Name: DMA_SETUP   is DMA_SETUP  & u15_19i=4 { export DMA_SETUP; }
          USR_Name: DMA_ISADDR  is DMA_ISADDR & u15_19i=5 { export DMA_ISADDR; }
          USR_Name: DMA_ESADDR  is DMA_ESADDR & u15_19i=6 { export DMA_ESADDR; }
          USR_Name: DMA_TCNT    is DMA_TCNT   & u15_19i=7 { export DMA_TCNT; }
          USR_Name: DMA_STATUS  is DMA_STATUS & u15_19i=8 { export DMA_STATUS; }
          USR_Name: DMA_2DSET   is DMA_2DSET  & u15_19i=9 { export DMA_2DSET; }
          USR_Name: DMA_2DSCTL  is DMA_2DSCTL & u15_19i=25 { export DMA_2DSCTL; }
        }
        with : u10_14i=2 {
          USR_Name: PFMC0   is PFMC0   & u15_19i=0 { export PFMC0; }
          USR_Name: PFMC1   is PFMC1   & u15_19i=1 { export PFMC1; }
          USR_Name: PFMC2   is PFMC2   & u15_19i=2 { export PFMC2; }
          USR_Name: PFM_CTL is PFM_CTL & u15_19i=4 { export PFM_CTL; }
        }
        :MFUSR u20_24, USR_Name is u20_24 & USR_Name & u6_9=0 & subop0_5=0b100000 { u20_24 = USR_Name; }
        :MFUSR u20_24, (= u15_19i, u10_14i) is u20_24 & u15_19i & u10_14i & u6_9=0 & subop0_5=0b100000 unimpl
        :MTUSR u20_24, USR_Name is u20_24 & USR_Name & u6_9=0 & subop0_5=0b100001 { USR_Name = u20_24; }
        :MTUSR u20_24, (= u15_19i, u10_14i) is u20_24 & u15_19i & u10_14i & u6_9=0 & subop0_5=0b100001 unimpl
    }

    # compute relative targets for branches
    imm14s_rel: rel is s0_13 [ rel = inst_start + (s0_13 << 1); ] { export *:4 rel; }
    imm16s_rel: rel is s0_15 [ rel = inst_start + (s0_15 << 1); ] { export *:4 rel; }
    imm24s_rel: rel is s0_23 [ rel = inst_start + (s0_23 << 1); ] { export *:4 rel; }

    with : $(BR1) {
        :BEQ u20_24, u15_19, imm14s_rel is u20_24 & u15_19 & u14_14=0 & imm14s_rel {
            branch_if(u20_24 == u15_19, imm14s_rel);
        }
        :BNE u20_24, u15_19, imm14s_rel is u20_24 & u15_19 & u14_14=1 & imm14s_rel {
            branch_if(u20_24 != u15_19, imm14s_rel);
        }
    }
    with : $(BR2) {
        :BEQZ u20_24, imm16s_rel is u20_24 & u16_19=0b0010 & imm16s_rel { branch_if(u20_24 == 0, imm16s_rel); }
        :BNEZ u20_24, imm16s_rel is u20_24 & u16_19=0b0011 & imm16s_rel { branch_if(u20_24 != 0, imm16s_rel); }
        :BGEZ u20_24, imm16s_rel is u20_24 & u16_19=0b0100 & imm16s_rel { branch_if(u20_24 s>= 0, imm16s_rel); }
        :BLTZ u20_24, imm16s_rel is u20_24 & u16_19=0b0101 & imm16s_rel { branch_if(u20_24 s< 0, imm16s_rel); }
        :BGTZ u20_24, imm16s_rel is u20_24 & u16_19=0b0110 & imm16s_rel { branch_if(u20_24 s> 0, imm16s_rel); }
        :BLEZ u20_24, imm16s_rel is u20_24 & u16_19=0b0111 & imm16s_rel { branch_if(u20_24 s<= 0, imm16s_rel); }
        :BGEZAL u20_24, imm16s_rel is u20_24 & u16_19=0b1100 & imm16s_rel {
            local bcond = u20_24;
            set_link_gpr(lp, inst_next);
            call_if(bcond s>= 0, imm16s_rel);
        }
        :BLTZAL u20_24, imm16s_rel is u20_24 & u16_19=0b1101 & imm16s_rel {
            local bcond = u20_24;
            set_link_gpr(lp, inst_next);
            call_if(bcond s< 0, imm16s_rel);
        }
    }
    with : $(JI) {
        :J   imm24s_rel is u24_24=0 & imm24s_rel { psw_ifcon_clear(); goto imm24s_rel; }
        :JAL imm24s_rel is u24_24=1 & imm24s_rel {
            set_link_gpr(lp, inst_next);
            psw_ifcon_clear();
            # TODO this should be branch (or: call with retaddr=IFC_LP hint), if flow has IFC_ON==1
            call imm24s_rel;
        }
    }
    with : $(JREG) {
        :JR  u10_14 is u15_24=0 & u10_14 & u8_9=0 & u6_7=0 & u5_5=0 & subop=0b00000 {
            psw_ifcon_clear();
            goto [u10_14];
        }
        :RET u10_14 is u15_24=0 & u10_14 & u8_9=0 & u6_7=0 & u5_5=1 & subop=0b00000 {
            psw_ifcon_clear();
            return [u10_14];
        }
        :JR."[T|IT]OFF" u10_14 is u15_24=0 & u10_14 & (u8_9=0b01 | u8_9=0b11) & u6_7=0 & u5_5=0 & subop=0b00000 {
            #PSW.IT = 0;
            #if (!(u8_9 == 0b11)) goto <do_branch>;
            #    PSW.DT = 0;
            #<do_branch>
            psw_ifcon_clear();
            goto [u10_14];
        }
        :JRAL u20_24, u10_14 is u20_24    & u15_19=0 & u10_14 & u8_9=0 & u5_7=0 & subop=0b00001 {
            local jaddr:4 = u10_14;
            set_link_gpr(u20_24, inst_next);
            psw_ifcon_clear();
            goto [jaddr];
        }
        # special case for call (Rt=LP)
        :JRAL u10_14         is u20_24i=30 & u15_19=0 & u10_14 & u8_9=0 & u5_7=0 & subop=0b00001 {
            local jaddr:4 = u10_14;
            set_link_gpr(lp, inst_next);
            psw_ifcon_clear();
            call [jaddr];
        }
        # special case for return (from leaf function: Rt=LP, Rb=LP)
        :JRAL u10_14         is u20_24i=30 & u15_19=0 & u10_14 & u10_14i=30 & u8_9=0 & u5_7=0 & subop=0b00001 {
            local jaddr:4 = u10_14;
            set_link_gpr(lp, inst_next);
            psw_ifcon_clear();
            # TODO ensure correct in IFC case (gdb has probably incorrect behavior of Rt=IFC_LP *after* Rb is read for jaddr, which we replicate)
            return [jaddr];
        }
        :JRAL."[T|IT]ON" u20_24, u10_14 is u20_24     & u15_19=0 & u10_14 & (u8_9=0b01 | u8_9=0b11) & u6_7=0 & u5_5=0 & subop=0b00000 {
            #PSW.IT = 1;
            #if (!(u8_9 == 0b11)) goto <do_branch>;
            #    PSW.DT = 1;
            #<do_branch>
            local jaddr:4 = u10_14;
            set_link_gpr(u20_24, inst_next);
            psw_ifcon_clear();
            goto [jaddr];
        }
        # special case for call
        :JRAL."[T|IT]ON" u10_14         is u20_24i=30 & u15_19=0 & u10_14 & (u8_9=0b01 | u8_9=0b11) & u6_7=0 & u5_5=0 & subop=0b00000 {
            #PSW.IT = 1;
            #if (!(u8_9 == 0b11)) goto <do_branch>;
            #    PSW.DT = 1;
            #<do_branch>
            local jaddr:4 = u10_14;
            set_link_gpr(lp, inst_next);
            psw_ifcon_clear();
            call [jaddr];
        }
        :RET."[T|IT]OFF" u10_14 is u15_24=0 & u10_14 & (u8_9=0b01 | u8_9=0b11) & u6_7=0 & u5_5=1 & subop=0b00000 {
            #PSW.IT = 0;
            #if (!(u8_9 == 0b11)) goto <do_branch>;
            #    PSW.DT = 0;
            #<do_branch>
            psw_ifcon_clear();
            return [u10_14];
        }
    }
    with : $(MISC) {
        # Generate_Exception
        :BREAK   u5_19 is u20_24=0 & u5_19 & subop=0b01010 { Exception_Breakpoint(u5_19:2); }

        :SYSCALL u5_19 is u20_24=0 & u5_19 & subop=0b01011 { Exception_System_Call(u5_19:2); }

        :TRAP    u5_19 is u20_24=0 & u5_19 & subop=0b00101 { Exception_Trap(u5_19:2); }
        :TEQZ    u20_24, u5_19 is u20_24 & u5_19 & subop=0b00110 {
            if (!(u20_24 == 0)) goto inst_next;
            Exception_Trap(u5_19:2);
        }
        :TNEZ    u20_24, u5_19 is u20_24 & u5_19 & subop=0b00111 {
            if (!(u20_24 != 0)) goto inst_next;
            Exception_Trap(u5_19:2);
        }

        # covers CCTL forms from V3 as well
        :CCTL u20_24, u15_19, u5_9i, u10_10 is u20_24 & u15_19 & u11_14=0 & u10_10 & u5_9i & subop=0b00001 {
            cctl(u20_24:1, u15_19:1, u5_9i:1, u10_10:1);
        }

        :DSB is u20_24=0 & u5_19=0 & subop=0b01000 { dsb(); }
        :ISB is u20_24=0 & u5_19=0 & subop=0b01001 { isb(); }

        :MSYNC MsyncSub is u20_24=0 & MsyncZ=0 & MsyncSub & subop=0b01100 { msync(MsyncSub:1); }
        :ISYNC u20_24 is u20_24 & u5_19=0 & subop=0b01101 { isync(u20_24:1); }

        :IRET is u20_24=0 & u5_19=0 & subop=0b00100 { return [IPC]; }

        with : SrMaj=0 {
          sridx: CPU_VER      is CPU_VER      & SrMin=0 & SrExt=0 { export CPU_VER; }
          sridx: ICM_CFG      is ICM_CFG      & SrMin=1 & SrExt=0 { export ICM_CFG; }
          sridx: DCM_CFG      is DCM_CFG      & SrMin=2 & SrExt=0 { export DCM_CFG; }
          sridx: MMU_CFG      is MMU_CFG      & SrMin=3 & SrExt=0 { export MMU_CFG; }
          sridx: MSC_CFG      is MSC_CFG      & SrMin=4 & SrExt=0 { export MSC_CFG; }
          sridx: MSC_CFG2     is MSC_CFG2     & SrMin=4 & SrExt=1 { export MSC_CFG2; }
          sridx: CORE_ID      is CORE_ID      & SrMin=0 & SrExt=1 { export CORE_ID; }
          sridx: FUCOP_EXIST  is FUCOP_EXIST  & SrMin=5 & SrExt=0 { export FUCOP_EXIST; }
        }
        with : SrMaj=1 {
          sridx: PSW          is PSW           & SrMin=0  & SrExt=0 { export PSW; }
          sridx: IPSW         is IPSW          & SrMin=0  & SrExt=1 { export IPSW; }
          sridx: P_IPSW       is P_IPSW        & SrMin=0  & SrExt=2 { export P_IPSW; }
          sridx: IVB          is IVB           & SrMin=1  & SrExt=1 { export IVB; }
          sridx: EVA          is EVA           & SrMin=2  & SrExt=1 { export EVA; }
          sridx: P_EVA        is P_EVA         & SrMin=2  & SrExt=2 { export P_EVA; }
          sridx: ITYPE        is ITYPE         & SrMin=3  & SrExt=1 { export ITYPE; }
          sridx: P_ITYPE      is P_ITYPE       & SrMin=3  & SrExt=2 { export P_ITYPE; }
          sridx: MERR         is MERR          & SrMin=4  & SrExt=1 { export MERR; }
          sridx: IPC          is IPC           & SrMin=5  & SrExt=1 { export IPC; }
          sridx: P_IPC        is P_IPC         & SrMin=5  & SrExt=2 { export P_IPC; }
          sridx: OIPC         is OIPC          & SrMin=5  & SrExt=3 { export OIPC; }
          sridx: P_P0         is P_P0          & SrMin=6  & SrExt=2 { export P_P0; }
          sridx: P_P1         is P_P1          & SrMin=7  & SrExt=2 { export P_P1; }
          sridx: INT_MASK     is INT_MASK      & SrMin=8  & SrExt=0 { export INT_MASK; }
          sridx: INT_PEND     is INT_PEND      & SrMin=9  & SrExt=0 { export INT_PEND; }
          sridx: SP_USR       is SP_USR        & SrMin=10 & SrExt=0 { export SP_USR; }
          sridx: SP_PRIV      is SP_PRIV       & SrMin=10 & SrExt=1 { export SP_PRIV; }
          sridx: INT_PRI      is INT_PRI       & SrMin=11 & SrExt=0 { export INT_PRI; }
          sridx: INT_CTRL     is INT_CTRL      & SrMin=1  & SrExt=2 { export INT_CTRL; }
          sridx: INT_MASK2    is INT_MASK2     & SrMin=8  & SrExt=1 { export INT_MASK2; }
          sridx: INT_PEND2    is INT_PEND2     & SrMin=9  & SrExt=1 { export INT_PEND2; }
          sridx: INT_PRI2     is INT_PRI2      & SrMin=11 & SrExt=1 { export INT_PRI2; }
          sridx: INT_TRIGGER  is INT_TRIGGER   & SrMin=9  & SrExt=4 { export INT_TRIGGER; }
        }
        with : SrMaj=2 & SrExt=0 {
          sridx: MMU_CTL    is MMU_CTL    & SrMin=0 { export MMU_CTL; }
          sridx: L1_PPTB    is L1_PPTB    & SrMin=1 { export L1_PPTB; }
          sridx: TLB_VPN    is TLB_VPN    & SrMin=2 { export TLB_VPN; }
          sridx: TLB_DATA   is TLB_DATA   & SrMin=3 { export TLB_DATA; }
          sridx: TLB_MISC   is TLB_MISC   & SrMin=4 { export TLB_MISC; }
          sridx: VLPT_IDX   is VLPT_IDX   & SrMin=5 { export VLPT_IDX; }
          sridx: ILMB       is ILMB       & SrMin=6 { export ILMB; }
          sridx: DLMB       is DLMB       & SrMin=7 { export DLMB; }
          sridx: CACHE_CTL  is CACHE_CTL  & SrMin=8 { export CACHE_CTL; }
          sridx: HSMP_SADDR is HSMP_SADDR & SrMin=9 { export HSMP_SADDR; }
        }
        with : SrMaj=2 & SrMin=15 {
          sridx: SDZ_CTL  is SDZ_CTL  & SrExt=0 { export SDZ_CTL; }
          sridx: MISC_CTL is MISC_CTL & SrExt=1 { export MISC_CTL; }
          sridx: ECC_MISC is ECC_MISC & SrExt=2 { export ECC_MISC; }
        }
        with : SrMaj=3 {
          sridx: BPC0     is BPC0     & SrMin=0  & SrExt=0 { export BPC0; }
          sridx: BPC1     is BPC1     & SrMin=0  & SrExt=1 { export BPC1; }
          sridx: BPC2     is BPC2     & SrMin=0  & SrExt=2 { export BPC2; }
          sridx: BPC3     is BPC3     & SrMin=0  & SrExt=3 { export BPC3; }
          sridx: BPC4     is BPC4     & SrMin=0  & SrExt=4 { export BPC4; }
          sridx: BPC5     is BPC5     & SrMin=0  & SrExt=5 { export BPC5; }
          sridx: BPC6     is BPC6     & SrMin=0  & SrExt=6 { export BPC6; }
          sridx: BPC7     is BPC7     & SrMin=0  & SrExt=7 { export BPC7; }
          sridx: BPA0     is BPA0     & SrMin=1  & SrExt=0 { export BPA0; }
          sridx: BPA1     is BPA1     & SrMin=1  & SrExt=1 { export BPA1; }
          sridx: BPA2     is BPA2     & SrMin=1  & SrExt=2 { export BPA2; }
          sridx: BPA3     is BPA3     & SrMin=1  & SrExt=3 { export BPA3; }
          sridx: BPA4     is BPA4     & SrMin=1  & SrExt=4 { export BPA4; }
          sridx: BPA5     is BPA5     & SrMin=1  & SrExt=5 { export BPA5; }
          sridx: BPA6     is BPA6     & SrMin=1  & SrExt=6 { export BPA6; }
          sridx: BPA7     is BPA7     & SrMin=1  & SrExt=7 { export BPA7; }
          sridx: BPAM0    is BPAM0    & SrMin=2  & SrExt=0 { export BPAM0; }
          sridx: BPAM1    is BPAM1    & SrMin=2  & SrExt=1 { export BPAM1; }
          sridx: BPAM2    is BPAM2    & SrMin=2  & SrExt=2 { export BPAM2; }
          sridx: BPAM3    is BPAM3    & SrMin=2  & SrExt=3 { export BPAM3; }
          sridx: BPAM4    is BPAM4    & SrMin=2  & SrExt=4 { export BPAM4; }
          sridx: BPAM5    is BPAM5    & SrMin=2  & SrExt=5 { export BPAM5; }
          sridx: BPAM6    is BPAM6    & SrMin=2  & SrExt=6 { export BPAM6; }
          sridx: BPAM7    is BPAM7    & SrMin=2  & SrExt=7 { export BPAM7; }
          sridx: BPV0     is BPV0     & SrMin=3  & SrExt=0 { export BPV0; }
          sridx: BPV1     is BPV1     & SrMin=3  & SrExt=1 { export BPV1; }
          sridx: BPV2     is BPV2     & SrMin=3  & SrExt=2 { export BPV2; }
          sridx: BPV3     is BPV3     & SrMin=3  & SrExt=3 { export BPV3; }
          sridx: BPV4     is BPV4     & SrMin=3  & SrExt=4 { export BPV4; }
          sridx: BPV5     is BPV5     & SrMin=3  & SrExt=5 { export BPV5; }
          sridx: BPV6     is BPV6     & SrMin=3  & SrExt=6 { export BPV6; }
          sridx: BPV7     is BPV7     & SrMin=3  & SrExt=7 { export BPV7; }
          sridx: BPCID0   is BPCID0   & SrMin=4  & SrExt=0 { export BPCID0; }
          sridx: BPCID1   is BPCID1   & SrMin=4  & SrExt=1 { export BPCID1; }
          sridx: BPCID2   is BPCID2   & SrMin=4  & SrExt=2 { export BPCID2; }
          sridx: BPCID3   is BPCID3   & SrMin=4  & SrExt=3 { export BPCID3; }
          sridx: BPCID4   is BPCID4   & SrMin=4  & SrExt=4 { export BPCID4; }
          sridx: BPCID5   is BPCID5   & SrMin=4  & SrExt=5 { export BPCID5; }
          sridx: BPCID6   is BPCID6   & SrMin=4  & SrExt=6 { export BPCID6; }
          sridx: BPCID7   is BPCID7   & SrMin=4  & SrExt=7 { export BPCID7; }
          sridx: EDM_CFG  is EDM_CFG  & SrMin=5  & SrExt=0 { export EDM_CFG; }
          sridx: EDMSW    is EDMSW    & SrMin=6  & SrExt=0 { export EDMSW; }
          sridx: EDM_CTL  is EDM_CTL  & SrMin=7  & SrExt=0 { export EDM_CTL; }
          sridx: EDM_DTR  is EDM_DTR  & SrMin=8  & SrExt=0 { export EDM_DTR; }
          sridx: BPMTC    is BPMTC    & SrMin=9  & SrExt=0 { export BPMTC; }
          sridx: DIMBR    is DIMBR    & SrMin=10 & SrExt=0 { export DIMBR; }
          sridx: TECR0    is TECR0    & SrMin=14 & SrExt=0 { export TECR0; }
          sridx: TECR1    is TECR1    & SrMin=14 & SrExt=1 { export TECR1; }
        }
        with : SrMaj=4 {
          sridx: PFMC0   is PFMC0   & SrMin=0 & SrExt=0 { export PFMC0; }
          sridx: PFMC1   is PFMC1   & SrMin=0 & SrExt=1 { export PFMC1; }
          sridx: PFMC2   is PFMC2   & SrMin=0 & SrExt=2 { export PFMC2; }
          sridx: PFM_CTL is PFM_CTL & SrMin=1 & SrExt=0 { export PFM_CTL; }
          sridx: PFT_CTL is PFT_CTL & SrMin=2 & SrExt=0 { export PFT_CTL; }

          sridx: PRUSR_ACC_CTL  is PRUSR_ACC_CTL  & SrMin=4 & SrExt=0 { export PRUSR_ACC_CTL; }
          sridx: FUCOP_CTL      is FUCOP_CTL      & SrMin=5 & SrExt=0 { export FUCOP_CTL; }
        }
        with : SrMaj=5 {
          sridx: DMA_CFG      is DMA_CFG      & SrMin=0 & SrExt=0 { export DMA_CFG; }
          sridx: DMA_GCSW     is DMA_GCSW     & SrMin=1 & SrExt=0 { export DMA_GCSW; }
          sridx: DMA_CHNSEL   is DMA_CHNSEL   & SrMin=2 & SrExt=0 { export DMA_CHNSEL; }
          sridx: DMA_ACT      is DMA_ACT      & SrMin=3 & SrExt=0 { export DMA_ACT; }
          sridx: DMA_SETUP    is DMA_SETUP    & SrMin=4 & SrExt=0 { export DMA_SETUP; }
          sridx: DMA_ISADDR   is DMA_ISADDR   & SrMin=5 & SrExt=0 { export DMA_ISADDR; }
          sridx: DMA_ESADDR   is DMA_ESADDR   & SrMin=6 & SrExt=0 { export DMA_ESADDR; }
          sridx: DMA_TCNT     is DMA_TCNT     & SrMin=7 & SrExt=0 { export DMA_TCNT; }
          sridx: DMA_STATUS   is DMA_STATUS   & SrMin=8 & SrExt=0 { export DMA_STATUS; }
          sridx: DMA_2DSET    is DMA_2DSET    & SrMin=9 & SrExt=0 { export DMA_2DSET; }
          sridx: DMA_2DSCTL   is DMA_2DSCTL   & SrMin=9 & SrExt=1 { export DMA_2DSCTL; }
          sridx: DMA_RCNT     is DMA_RCNT     & SrMin=7 & SrExt=1 { export DMA_RCNT; }
          sridx: DMA_HSTATUS  is DMA_HSTATUS  & SrMin=8 & SrExt=1 { export DMA_HSTATUS; }
        }
        :MFSR u20_24, sridx is u20_24 & sridx & u5_9i=0 & subop=0b00010 { u20_24 = sridx; }
        # TODO this hits bug in sleigh compiler: https://github.com/NationalSecurityAgency/ghidra/issues/6676
        #:MFSR u20_24, (SrMaj, SrMin, SrExt) is u20_24 & SrMaj & SrMin & SrExt & u5_9i=0 & subop=0b00010 unimpl
        :MTSR u20_24, sridx is u20_24 & sridx & u5_9i=0 & subop=0b00011 { sridx = u20_24; }
        #:MTSR u20_24, (SrMaj, SrMin, SrExt) is u20_24 & SrMaj & SrMin & SrExt & u5_9i=0 & subop=0b00011 unimpl

        :SETEND.^setend20 is u21_24=0 & setend20 & u10_19=0b0010000000 & u5_9i=0b00001 & subop=0b00011 { setend(setend20:1); }
        :SETGIE.^setgie20 is u21_24=0 & setgie20 & u10_19=0b0010000000 & u5_9i=0b00010 & subop=0b00011 { setgie(setgie20:1); }

        :STANDBY is u20_24=0 & u10_19=0 & u7_9=0 & standby5_6 & subop=0b00000 { standby(standby5_6:1); }

        define pcodeop TLB_TargetRead;
        define pcodeop TLB_TargetWrite;
        define pcodeop TLB_RWrite;
        define pcodeop TLB_RWriteLock;
        define pcodeop TLB_Unlock;
        define pcodeop TLB_Probe;
        define pcodeop TLB_Invalidate;
        define pcodeop TLB_FlushAll;
        with : Rb=0 & Sub5=0b01110 {
            :TLBOP Ra,"TargetRead"  is Rt & Ra & TlbopSub=0 { TLB_TargetRead(Ra:4); }
            :TLBOP Ra,"TargetWrite" is Rt & Ra & TlbopSub=1 { TLB_TargetWrite(Ra:4); }
            :TLBOP Ra,"RWrite"      is Rt & Ra & TlbopSub=2 { TLB_RWrite(Ra:4); }
            :TLBOP Ra,"RWriteLock"  is Rt & Ra & TlbopSub=3 { TLB_RWriteLock(Ra:4); }
            :TLBOP Ra,"Unlock"      is Rt & Ra & TlbopSub=4 { TLB_Unlock(Ra:4); }
            :TLBOP Rt,Ra,"Probe"    is Rt & Ra & TlbopSub=5 { TLB_Probe(Rt:4, Ra:4); }
            :TLBOP Ra,"Invalidate"  is Rt & Ra & TlbopSub=6 { TLB_Invalidate(Ra:4); }
            :TLBOP "FlushAll"       is Rt & Ra & TlbopSub=7 { TLB_FlushAll(); }
        }
    }
    with : $(MEM) {
        addr1  : [u15_19 + (u10_14 "<<" u8_9)] is u15_19 & u10_14 & u8_9 { local addr:4 = u15_19 + (u10_14 << u8_9); export addr; }
        addr1bi: [u15_19], (u10_14 "<<" u8_9)  is u15_19 & u10_14 & u8_9 { bi_addr = u15_19 + (u10_14 << u8_9); export u15_19; }

        :DPREF dpref20_23, addr1 is u24_24=0 & dpref20_23 & addr1 & u0_7=0b00010011 unimpl

        :LB     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00000000 { u20_24 = zext(*:1 addr1); }
        :LB.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00000100 { u20_24 = zext(*:1 addr1bi); u15_19 = bi_addr; }
        :LBS    u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00010000 { u20_24 = sext(*:1 addr1); }
        :LBS.bi u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00010100 { u20_24 = sext(*:1 addr1bi); u15_19 = bi_addr; }
        :LH     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00000001 { u20_24 = zext(*:2 addr1); }
        :LH.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00000101 { u20_24 = zext(*:2 addr1bi); u15_19 = bi_addr; }
        :LHS    u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00010001 { u20_24 = sext(*:2 addr1); }
        :LHS.bi u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00010101 { u20_24 = sext(*:2 addr1bi); u15_19 = bi_addr; }
        :LW     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00000010 { u20_24 = *:4 addr1; }
        :LW.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00000110 { u20_24 = *:4 addr1bi; u15_19 = bi_addr; }
        :LLW    u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00011000 unimpl
        :LWUP   u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00100010 unimpl

        :SB     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00001000 { *:1 addr1   = u20_24:1; }
        :SB.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00001100 { *:1 addr1bi = u20_24:1; u15_19 = bi_addr; }
        :SH     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00001001 { *:2 addr1   = u20_24:2; }
        :SH.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00001101 { *:2 addr1bi = u20_24:2; u15_19 = bi_addr; }
        :SW     u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00001010 { *:4 addr1   = u20_24:4; }
        :SW.bi  u20_24, addr1bi  is u20_24 & u15_19 & addr1bi & u0_7=0b00001110 { *:4 addr1bi = u20_24:4; u15_19 = bi_addr; }
        :SCW    u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00011001 unimpl
        :SWUP   u20_24, addr1    is u20_24 &          addr1   & u0_7=0b00101010 unimpl
    }
    with : $(LSMW) {
        LsmwBa_: "b" is LsmwBa=0 { }
        LsmwBa_: "a" is LsmwBa=1 { }
        LsmwId_: "i" is LsmwId=0 { }
        LsmwId_: "d" is LsmwId=1 { }
        LsmwM_: ""  is LsmwRa & LsmwM=0 { }
        LsmwM_: "m" is LsmwRa & LsmwM=1 { LsmwRa = mult_addr; }

        :LMW.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=0 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b00 & Lmw.regs {
            mult_addr = LsmwRa;
            build Lmw.regs;
            build LsmwM_;
        }
        :SMW.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=1 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b00 & Smw.regs {
            mult_addr = LsmwRa;
            build Smw.regs;
            build LsmwM_;
        }
    }

    addr20  : [u15_19 + s0_14] is u15_19 & s0_14 { local addr:4 = u15_19 + s0_14; export addr; }
    addr20bi: [u15_19], s0_14  is u15_19 & s0_14 { bi_addr = u15_19 + s0_14; export u15_19; }
    # go against documentation and resolve effective immediate
    addr21  : [u15_19 + imm] is u15_19 & s0_14 [imm = s0_14 << 1;] { local addr:4 = u15_19 + imm; export addr; }
    addr21bi: [u15_19], imm  is u15_19 & s0_14 [imm = s0_14 << 1;] { bi_addr = u15_19 + imm; export u15_19; }
    addr22  : [u15_19 + imm] is u15_19 & s0_14 [imm = s0_14 << 2;] { local addr:4 = u15_19 + imm; export addr; }
    addr22bi: [u15_19], imm  is u15_19 & s0_14 [imm = s0_14 << 2;] { bi_addr = u15_19 + imm; export u15_19; }
    addr23  : [u15_19 + imm] is u15_19 & s0_14 [imm = s0_14 << 3;] { local addr:4 = u15_19 + imm; export addr; }

    :DPREFI.^dprefi24, dpref20_23, addr22 is opc=0b010011 & dprefi24 & dprefi24=0 & dpref20_23 & addr22 unimpl # w
    :DPREFI.^dprefi24, dpref20_23, addr23 is opc=0b010011 & dprefi24 & dprefi24=1 & dpref20_23 & addr23 unimpl # d

    :LBI      u20_24, addr20    is opc=0b000000 & u20_24 &          addr20   { u20_24 = zext(*:1 addr20); }
    :LBI.bi   u20_24, addr20bi  is opc=0b000100 & u20_24 & u15_19 & addr20bi { u20_24 = zext(*:1 addr20bi); u15_19 = bi_addr; }
    :LBSI     u20_24, addr20    is opc=0b010000 & u20_24 &          addr20   { u20_24 = sext(*:1 addr20); }
    :LBSI.bi  u20_24, addr20bi  is opc=0b010100 & u20_24 & u15_19 & addr20bi { u20_24 = sext(*:1 addr20bi); u15_19 = bi_addr; }
    :LHI      u20_24, addr21    is opc=0b000001 & u20_24 &          addr21   { u20_24 = zext(*:2 addr21); }
    :LHI.bi   u20_24, addr21bi  is opc=0b000101 & u20_24 & u15_19 & addr21bi { u20_24 = zext(*:2 addr21bi); u15_19 = bi_addr; }
    :LHSI     u20_24, addr21    is opc=0b010001 & u20_24 &          addr21   { u20_24 = sext(*:2 addr21); }
    :LHSI.bi  u20_24, addr21bi  is opc=0b010101 & u20_24 & u15_19 & addr21bi { u20_24 = sext(*:2 addr21bi); u15_19 = bi_addr; }
    :LWI      u20_24, addr22    is opc=0b000010 & u20_24 &          addr22   { u20_24 = *:4 addr22; }
    :LWI.bi   u20_24, addr22bi  is opc=0b000110 & u20_24 & u15_19 & addr22bi { u20_24 = *:4 addr22bi; u15_19 = bi_addr; }

    :SBI      u20_24, addr20    is opc=0b001000 & u20_24 &          addr20   { *:1 addr20   = u20_24:1; }
    :SBI.bi   u20_24, addr20bi  is opc=0b001100 & u20_24 & u15_19 & addr20bi { *:1 addr20bi = u20_24:1; u15_19 = bi_addr; }
    :SHI      u20_24, addr21    is opc=0b001001 & u20_24 &          addr21   { *:2 addr21   = u20_24:2; }
    :SHI.bi   u20_24, addr21bi  is opc=0b001101 & u20_24 & u15_19 & addr21bi { *:2 addr21bi = u20_24:2; u15_19 = bi_addr; }
    :SWI      u20_24, addr22    is opc=0b001010 & u20_24 &          addr22   { *:4 addr22   = u20_24:4; }
    :SWI.bi   u20_24, addr22bi  is opc=0b001110 & u20_24 & u15_19 & addr22bi { *:4 addr22bi = u20_24:4; u15_19 = bi_addr; }

    :ADDI  u20_24, u15_19, s0_14 is opc=0b101000 & u20_24 & u15_19 & s0_14 { u20_24 = u15_19 + s0_14; }
    :ANDI  u20_24, u15_19, u0_14 is opc=0b101010 & u20_24 & u15_19 & u0_14 { u20_24 = u15_19 & u0_14; }
    :ZEB   u20_24, u15_19        is opc=0b101010 & u20_24 & u15_19 & u0_14=0xff { u20_24 = zext(u15_19:1); }
    :ORI   u20_24, u15_19, u0_14 is opc=0b101100 & u20_24 & u15_19 & u0_14 { u20_24 = u15_19 | u0_14; }
    :XORI  u20_24, u15_19, u0_14 is opc=0b101011 & u20_24 & u15_19 & u0_14 { u20_24 = u15_19 ^ u0_14; }
    :SUBRI u20_24, u15_19, s0_14 is opc=0b101001 & u20_24 & u15_19 & s0_14 { u20_24 = s0_14 - u15_19; }
    :SLTI  u20_24, u15_19, s0_14 is opc=0b101110 & u20_24 & u15_19 & s0_14 { u20_24 = zext(u15_19  < s0_14); }
    :SLTSI u20_24, u15_19, s0_14 is opc=0b101111 & u20_24 & u15_19 & s0_14 { u20_24 = zext(u15_19 s< s0_14); }

    :MOVI  u20_24, s0_19 is opc=0b100010 & u20_24 & s0_19 { u20_24 = s0_19; }
    :SETHI u20_24, u0_19 is opc=0b100011 & u20_24 & u0_19 { u20_24 = u0_19 << 12; }

############# V1 Performance Extensions

    with : $(ALU_2) {
        :ABS   u20_24, u15_19          is u20_24 & u15_19 & u10_14=0 & u6_9=0 & subop0_5=0b000011 {
            local ra = u15_19;
            if (ra s>= 0) goto <set_val>;
            if (ra == 0x80000000) goto <set_max>;
            u20_24 = -ra;
            goto inst_next;
            <set_val>
            u20_24 = ra;
            goto inst_next;
            <set_max>
            u20_24 = 0x7fffffff;
        }
        :AVE   u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14   & u6_9=0 & subop0_5=0b000010 { u20_24 = (u15_19 + u10_14) s>> 2; }
        :BCLR  u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b001001 { u20_24 = u15_19 & ~(1 << u10_14i); }
        :BSET  u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b001000 { u20_24 = u15_19 |  (1 << u10_14i); }
        :BTGL  u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b001010 { u20_24 = u15_19 ^  (1 << u10_14i); }
        :BTST  u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b001011 { u20_24 = zext((u15_19 &  (1 << u10_14i)) != 0); }
        :CLIP  u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b000101 {
            local max:4 = (1 << u10_14i) - 1;
            local min:4 = 0;
            local ra = u15_19;
            if (ra s> max) goto <set_max>;
            if (ra s< min) goto <set_zero>;
            u20_24 = ra;
            goto inst_next;
            <set_max>
            u20_24 = max;
            goto inst_next;
            <set_zero>
            u20_24 = 0;
        }
        :CLIPS u20_24, u15_19, u10_14i is u20_24 & u15_19 & u10_14i  & u6_9=0 & subop0_5=0b000100 {
            local max:4 = (1 << u10_14i) - 1;
            local min:4 = -(1 << u10_14i);
            local ra = u15_19;
            if (ra s> max) goto <set_max>;
            if (ra s< min) goto <set_zero>;
            u20_24 = ra;
            goto inst_next;
            <set_max>
            u20_24 = max;
            goto inst_next;
            <set_zero>
            u20_24 = 0;
        }
        :CLO   u20_24, u15_19          is u20_24 & u15_19 &           u6_14=0 & subop0_5=0b000110 { u20_24 = lzcount(~u15_19); }
        :CLZ   u20_24, u15_19          is u20_24 & u15_19 &           u6_14=0 & subop0_5=0b000111 { u20_24 = lzcount(u15_19); }
        :MAX   u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14   & u6_9=0 & subop0_5=0b000000 {
            if (u15_19 s>= u10_14) goto <set_ra>;
            u20_24 = u10_14;
            goto inst_next;
            <set_ra>
            u20_24 = u15_19;
        }
        :MIN   u20_24, u15_19, u10_14  is u20_24 & u15_19 & u10_14   & u6_9=0 & subop0_5=0b000001 {
            if (u15_19 s>= u10_14) goto <set_rb>;
            u20_24 = u15_19;
            goto inst_next;
            <set_rb>
            u20_24 = u10_14;
        }
    }

############# STRING Extension

    with : $(ALU_2) {
        :FFB    Rt, Ra, Rb    is Rt & Ra & Rb & u7_9=0 & subop0_6=0b0001110 unimpl
        :FFBI   Rt, Ra, u7_14 is Rt & Ra & u7_14       & subop0_6=0b1001110 unimpl
        :FFMISM Rt, Ra, Rb    is Rt & Ra & Rb & u7_9=0 & subop0_6=0b0001111 unimpl
        :FLMISM Rt, Ra, Rb    is Rt & Ra & Rb & u7_9=0 & subop0_6=0b1001111 unimpl
    }

############# V2 Baseline

    gprel17: [+rel] is s0_16 [rel = s0_16 << 2;] { local addr:4 = gp + rel; export addr; }
    gprel18: [+rel] is s0_17 [rel = s0_17 << 1;] { local addr:4 = gp + rel; export addr; }
    gprel19: [+s0_18] is s0_18 { local addr:4 = gp + s0_18; export addr; }

    with : $(ALU_1) {
        # TODO check div by zero and IDIVZE state
        # NOTE register order in disasm differs from instruction bitfield
        :DIVR u20_24, u5_9, u15_19, u10_14 is u20_24 & u20_24i & u15_19 & u10_14 & u5_9 & u5_9i & subop=0b10111 {
            local a:4 = u15_19;
            local b:4 = u10_14;
            u20_24 = a / b;
            # TODO dont emit pcode for this comparison, it could be constant
            if (!(u5_9i:1 != u20_24i:1)) goto inst_next;
            u5_9 = a % b;
        }
        :DIVSR u20_24, u5_9, u15_19, u10_14 is u20_24 & u20_24i & u15_19 & u10_14 & u5_9 & u5_9i & subop=0b10110 {
            local a:4 = u15_19;
            local b:4 = u10_14;
            u20_24 = a s/ b;
            if (!(u5_9i:1 != u20_24i:1)) goto inst_next;
            u5_9 = a s% b;
        }
    }
    with : $(ALU_2) {
        :MADDR32 u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & u6_9=0b0001 & subop0_5=0b110011 {
            local a:4 = u15_19;
            local b:4 = u10_14;
            local m:4 = a * b;
            u20_24 = u20_24 + m;
        }
        :MSUBR32 u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & u6_9=0b0001 & subop0_5=0b110101 {
            local a:4 = u15_19;
            local b:4 = u10_14;
            local m:4 = a * b;
            u20_24 = u20_24 - m;
        }
        :MULR64  u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & u6_9=0b0001 & subop0_5=0b101001 {
            local a:8 = zext(u15_19);
            local b:8 = zext(u10_14);
            local m:8 = a * b;
            local l:4 = m:4;
            local h:4 = m(4);
            # TODO Assumes PSW.BE==0
            local rt0:4 = &u20_24 & ~3;
            local rt1:4 = rt0 + 4;
            *[register]:4 rt0 = l;
            *[register]:4 rt1 = h;
        }
        :MULSR64 u20_24, u15_19, u10_14 is u20_24 & u15_19 & u10_14 & u6_9=0b0001 & subop0_5=0b101000 {
            local a:8 = sext(u15_19);
            local b:8 = sext(u10_14);
            local m:8 = a * b;
            local l:4 = m:4;
            local h:4 = m(4);
            # TODO Assumes PSW.BE==0
            local rt0:4 = &u20_24 & ~3;
            local rt1:4 = rt0 + 4;
            *[register]:4 rt0 = l;
            *[register]:4 rt1 = h;
        }
    }
    with : $(LBGP) {
        :LBI.gp  u20_24, gprel19 is u20_24 & u19_19=0 & gprel19 { u20_24 = zext(*:1 gprel19); }
        :LBSI.gp u20_24, gprel19 is u20_24 & u19_19=1 & gprel19 { u20_24 = sext(*:1 gprel19); }
    }
    with : $(SBGP) {
        :SBI.gp u20_24, gprel19 is u20_24 & u19_19=0 & gprel19 { *:1 gprel19 = u20_24:1; }
        :ADDI.gp u20_24, s0_18 is u20_24 & u19_19=1 & s0_18 { u20_24 = gp + s0_18; }
    }
    with : $(HWGP) {
        :LHI.gp  u20_24, gprel18 is u20_24 & hwgp18_19=0b00  & gprel18 { u20_24 = zext(*:2 gprel18); }
        :LHSI.gp u20_24, gprel18 is u20_24 & hwgp18_19=0b01  & gprel18 { u20_24 = sext(*:2 gprel18); }
        :LWI.gp  u20_24, gprel17 is u20_24 & hwgp17_19=0b110 & gprel17 { u20_24 = *:4 gprel17; }

        :SHI.gp  u20_24, gprel18 is u20_24 & hwgp18_19=0b10  & gprel18 { *:2 gprel18 = u20_24:2; }
        :SWI.gp  u20_24, gprel17 is u20_24 & hwgp17_19=0b111 & gprel17 { *:4 gprel17 = u20_24:4; }
    }
    with : $(LSMW) {
        # Difference from LMW/SMW is that this requires Ra be word aligned, and fp/sp order are inverted.
        # XXX gdb reverses order of all 4 special regs instead of just swapping fp/sp - explicitly against the manual.
        :LMWA.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=0 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b01 & Lmwa.regs {
            mult_addr = LsmwRa;
            build Lmwa.regs;
            build LsmwM_;
        }
        :SMWA.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=1 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b01 & Smwa.regs {
            mult_addr = LsmwRa;
            build Smwa.regs;
            build LsmwM_;
        }
    }
    with : $(MEM) {
        :LBUP u20_24, addr1 is u20_24 & addr1 & u0_7=0b00100000 unimpl
        :SBUP u20_24, addr1 is u20_24 & addr1 & u0_7=0b00101000 unimpl
    }

############# V2 Performance Extensions

    with : $(ALU_2) & $(ALU2Z) {
        :BSE is Rt & Ra & Rb & Sub6=0b001100 unimpl
        :BSP is Rt & Ra & Rb & Sub6=0b001101 unimpl
    }

    macro add_abs_diff(dst, src1, src2, shift) {
        local src1_ = src1 >> shift;
        local src2_ = src2 >> shift;
        local a = src1_:1 - src2_:1;
        local agez:1 = a s>= 0;
        local altz:1 = a s< 0;
        local aabs:1 = (a * agez) | ((-a) * altz);
        dst = dst + zext(aabs);
    }
    with : $(SIMD) & Rd=0 {
        :PBSAD Rt, Ra, Rb is Rt & Ra & Rb & Sub5=0b0000 {
            Rt = 0;
            add_abs_diff(Rt, Ra, Rb, 0);
            add_abs_diff(Rt, Ra, Rb, 8);
            add_abs_diff(Rt, Ra, Rb, 16);
            add_abs_diff(Rt, Ra, Rb, 24);
        }
        :PBSADA Rt, Ra, Rb is Rt & Ra & Rb & Sub5=0b0001 {
            add_abs_diff(Rt, Ra, Rb, 0);
            add_abs_diff(Rt, Ra, Rb, 8);
            add_abs_diff(Rt, Ra, Rb, 16);
            add_abs_diff(Rt, Ra, Rb, 24);
        }
    }

############# V3 Baseline

    with : $(ALU_1) {
        :BITC       u20_24, u15_19, u10_14        is u20_24 & u15_19 & u10_14 & u5_9i=0b00000 & subop=0b10010 { u20_24 = u15_19 & ~u10_14; }
        :ADD_SLLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b00000 { u20_24 = u15_19 + (u10_14 << u5_9i); }
        :ADD_SRLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b11100 { u20_24 = u15_19 + (u10_14 >> u5_9i); }
        :AND_SLLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b00010 { u20_24 = u15_19 & (u10_14 << u5_9i); }
        :AND_SRLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b11110 { u20_24 = u15_19 & (u10_14 >> u5_9i); }
        :OR_SLLI    u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b00100 { u20_24 = u15_19 | (u10_14 << u5_9i); }
        :OR_SRLI    u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b10101 { u20_24 = u15_19 | (u10_14 >> u5_9i); }
        :SUB_SLLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b00001 { u20_24 = u15_19 - (u10_14 << u5_9i); }
        :SUB_SRLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b11101 { u20_24 = u15_19 - (u10_14 >> u5_9i); }
        :XOR_SLLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b00011 { u20_24 = u15_19 ^ (u10_14 << u5_9i); }
        :XOR_SRLI   u20_24, u15_19, u10_14, u5_9i is u20_24 & u15_19 & u10_14 & u5_9i & subop=0b11111 { u20_24 = u15_19 ^ (u10_14 >> u5_9i); }
    }
    with : $(BR3) {
        imm8s_rel: rel is s0_7 [ rel = inst_start + (s0_7 << 1); ] { export *:4 rel; }
        :BEQC u20_24, s8_18, imm8s_rel is u20_24 & s8_18 & imm8s_rel & u19_19=0 { branch_if(u20_24 == s8_18, imm8s_rel); }
        :BNEC u20_24, s8_18, imm8s_rel is u20_24 & s8_18 & imm8s_rel & u19_19=1 { branch_if(u20_24 != s8_18, imm8s_rel); }
    }
    with : $(BITCI) {
        :BITCI u20_24, u15_19, u0_14 is u20_24 & u15_19 & u0_14 { u20_24 = u15_19 & ~u0_14; }
    }
    with : $(JREG) & u5_9=0 {
        :JRALNEZ    u20_24, u10_14  is u20_24    & u10_14 & subop=0b00011 {
            local jaddr:4 = u10_14;

            set_link_gpr(u20_24, inst_next);
            psw_ifcon_clear();

            if (!(jaddr != 0)) goto inst_next;
            goto [jaddr];
        }
        # special case for Rt=LP
        :JRALNEZ    u10_14          is u20_24=30 & u10_14 & subop=0b00011 {
            local jaddr:4 = u10_14;

            set_link_gpr(lp, inst_next);
            psw_ifcon_clear();

            if (!(jaddr != 0)) goto inst_next;
            call [jaddr];
        }
        :JRNEZ      u10_14          is u20_24=0  & u10_14 & subop=0b00010 {
            if (!(u10_14 != 0)) goto inst_next;
            psw_ifcon_clear();
            goto [u10_14];
        }
    }

############# DSP ISA Extension

    # SOP0
    with : $(BR2) & u16_19=0b0000 {
        :IFCALL imm16s_rel is u20_24=0b00000 & imm16s_rel {
            ifcall(imm16s_rel);
        }

        # ZOL (Zero Overhead Loop) Optional
        :MTLBI imm16s_rel is u20_24=0b00001 & imm16s_rel { LB = inst_start + imm16s_rel; }
        :MTLEI imm16s_rel is u20_24=0b00010 & imm16s_rel { LE = inst_start + imm16s_rel; }
    }
    with : $(JREG) {
        # haven't seen this used, but it's in binutils
        :IFRET is u20_24=0 & u15_19=0 & u5_14=0b11 & subop=0b00000 {
            ifret();
        }
    }
}

@define I16     "(opsz=1)"
@define BFMI333 "(opc6=0b001011)"
@define XWI37   "(opc4=0b0111)"
@define XWI37SP "(opc4=0b1110)"
@define MISC33  "(opc6=0b111111)"

with : $(I16) {
    with : $(BFMI333) {
        :ZEB33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b000 { R3_6_8 = zext(R3_3_5:1); }
        :ZEH33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b001 { R3_6_8 = zext(R3_3_5:2); }
        :SEB33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b010 { R3_6_8 = sext(R3_3_5:1); }
        :SEH33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b011 { R3_6_8 = sext(R3_3_5:2); }
        :XLSB33 R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b100 { R3_6_8 = R3_3_5 & 1; }
        :X11B33 R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b101 { R3_6_8 = R3_3_5 & 0x7ff; }
    }
    with : $(XWI37) {
        fprel: [fp + rel] is fp & imm7u [rel = imm7u << 2;] { local addr:4 = fp + rel; export addr; }
        :LWI37 R3_8_10, fprel is R3_8_10 & lwi37=0 & fprel { R3_8_10 = *:4 fprel; }
        :SWI37 R3_8_10, fprel is R3_8_10 & lwi37=1 & fprel { *:4 fprel = R3_8_10; }
    }

    addr30  : [R3_3_5, imm3u] is R3_3_5 & imm3u { local addr:4 = R3_3_5 + imm3u; export addr; }
    addr31  : [R3_3_5, imm]   is R3_3_5 & imm3u [imm = imm3u << 1;] { local addr:4 = R3_3_5 + imm; export addr; }
    addr32  : [R3_3_5, imm]   is R3_3_5 & imm3u [imm = imm3u << 2;] { local addr:4 = R3_3_5 + imm; export addr; }
    addr32bi: [R3_3_5, imm]   is R3_3_5 & imm3u [imm = imm3u << 2;] { bi_addr = R3_3_5 + imm; export R3_3_5; }

    :LBI333    R3_6_8, addr30   is op9_14=0b010011 & R3_6_8 &          addr30   { R3_6_8 = zext(*:1 addr30); }
    :LHI333    R3_6_8, addr31   is op9_14=0b010010 & R3_6_8 &          addr31   { R3_6_8 = zext(*:2 addr31); }
    :LWI333    R3_6_8, addr32   is op9_14=0b010000 & R3_6_8 &          addr32   { R3_6_8 = *:4 addr32; }
    :LWI333.bi R3_6_8, addr32bi is op9_14=0b010001 & R3_6_8 & R3_3_5 & addr32bi { R3_6_8 = *:4 addr32bi; R3_3_5 = bi_addr; }

    :SBI333    R3_6_8, addr30   is op9_14=0b010111 & R3_6_8 &          addr30   { *:1 addr30   = R3_6_8:1; }
    :SHI333    R3_6_8, addr31   is op9_14=0b010110 & R3_6_8 &          addr31   { *:2 addr31   = R3_6_8:2; }
    :SWI333    R3_6_8, addr32   is op9_14=0b010100 & R3_6_8 &          addr32   { *:4 addr32   = R3_6_8:4; }
    :SWI333.bi R3_6_8, addr32bi is op9_14=0b010101 & R3_6_8 & R3_3_5 & addr32bi { *:4 addr32bi = R3_6_8:4; R3_3_5 = bi_addr; }

    addr4: [R5_0_4] is R5_0_4 { export R5_0_4; }
    :LWI450 R4_5_8, addr4 is op9_14=0b011010 & R4_5_8 & addr4 { R4_5_8 = *:4 addr4; }
    :SWI450 R4_5_8, addr4 is op9_14=0b011011 & R4_5_8 & addr4 { *:4 addr4 = R4_5_8:4; }

    imm8s_rel: rel is imm8s [ rel = inst_start + (imm8s << 1); ] { export *:4 rel; }
    :BEQZ38 R3_8_10, imm8s_rel is op11_14=0b1000 & R3_8_10 & imm8s_rel { branch_if(R3_8_10 == 0, imm8s_rel); }
    :BNEZ38 R3_8_10, imm8s_rel is op11_14=0b1001 & R3_8_10 & imm8s_rel { branch_if(R3_8_10 != 0, imm8s_rel); }
    # if R3_8_10 == R5(a5), it's J8
    :BEQS38 R3_8_10, imm8s_rel is op11_14=0b1010 & R3_8_10 & imm8s_rel { branch_if(R3_8_10 == a5, imm8s_rel); }
    :BNES38 R3_8_10, imm8s_rel is op11_14=0b1011 & R3_8_10 & imm8s_rel { branch_if(R3_8_10 != a5, imm8s_rel); }
    :BEQZS8 imm8s_rel is op8_14=0b1101000 & imm8s_rel { branch_if(ta == 0, imm8s_rel); }
    :BNEZS8 imm8s_rel is op8_14=0b1101001 & imm8s_rel { branch_if(ta != 0, imm8s_rel); }

    # V3 ISA modifies BREAK16 such that imm4u is zero. nonzero imm4u encodes EX9.IT instead.
    :BREAK16 imm5u is op9_14=0b110101 & imm4u=0 & imm5u { Exception_Breakpoint(imm5u:1); }

    :J8 imm8s_rel is op8_14=0b1010101 & imm8s_rel { psw_ifcon_clear(); goto imm8s_rel; }
    :JR5   R5_0_4 is op5_14=0b1011101000 & R5_0_4 { psw_ifcon_clear(); goto [R5_0_4]; }
    :JRAL5 R5_0_4 is op5_14=0b1011101001 & R5_0_4 { set_link_gpr(lp, inst_next); psw_ifcon_clear(); call [R5_0_4]; }

    :RET5 R5_0_4 is op5_14=0b1011101100 & R5_0_4 { return [R5_0_4]; }

    :MOV55  R5_5_9, R5_0_4 is op10_14=0b00000 & R5_5_9 & R5_0_4 { R5_5_9 = R5_0_4; }
    :MOVI55 R5_5_9, imm5s  is op10_14=0b00001 & R5_5_9 & imm5s { R5_5_9 = imm5s; }

    # special case of SRLI45 R0,0
    :NOP16 is op9_14=0b001001 & R4_5_8=0 & R5_0_4=0 {}

    :ADD333 R3_6_8, R3_3_5, R3_0_2 is op9_14=0b001100 & R3_6_8 & R3_3_5 & R3_0_2 { R3_6_8 = R3_3_5 + R3_0_2; }
    :SUB333 R3_6_8, R3_3_5, R3_0_2 is op9_14=0b001101 & R3_6_8 & R3_3_5 & R3_0_2 { R3_6_8 = R3_3_5 - R3_0_2; }

    :ADDI333 R3_6_8, R3_3_5, imm3u is op9_14=0b001110 & R3_6_8 & R3_3_5 & imm3u { R3_6_8 = R3_3_5 + imm3u; }
    :SLLI333 R3_6_8, R3_3_5, imm3u is op9_14=0b001010 & R3_6_8 & R3_3_5 & imm3u { R3_6_8 = R3_3_5 << imm3u; }
    :SUBI333 R3_6_8, R3_3_5, imm3u is op9_14=0b001111 & R3_6_8 & R3_3_5 & imm3u { R3_6_8 = R3_3_5 - imm3u; }

    :ADD45   R4_5_8, R5_0_4 is op9_14=0b000100 & R4_5_8 & R5_0_4 { R4_5_8 = R4_5_8 + R5_0_4; }
    :SLT45   R4_5_8, R5_0_4 is op9_14=0b110001 & R4_5_8 & R5_0_4 { ta = zext(R4_5_8 < R5_0_4); }
    :SLTS45  R4_5_8, R5_0_4 is op9_14=0b110000 & R4_5_8 & R5_0_4 { ta = zext(R4_5_8 s< R5_0_4); }
    :SUB45   R4_5_8, R5_0_4 is op9_14=0b000101 & R4_5_8 & R5_0_4 { R4_5_8 = R4_5_8 - R5_0_4; }

    :ADDI45  R4_5_8, imm5u is op9_14=0b000110 & R4_5_8 & imm5u { R4_5_8 = R4_5_8 + imm5u; }
    :SLTI45  R4_5_8, imm5u is op9_14=0b110011 & R4_5_8 & imm5u { ta = zext(R4_5_8 < imm5u); }
    :SLTSI45 R4_5_8, imm5u is op9_14=0b110010 & R4_5_8 & imm5u { ta = zext(R4_5_8 s< imm5u); }
    :SRAI45  R4_5_8, imm5u is op9_14=0b001000 & R4_5_8 & imm5u { R4_5_8 = R4_5_8 s>> imm5u; }
    :SRLI45  R4_5_8, imm5u is op9_14=0b001001 & R4_5_8 & imm5u { R4_5_8 = R4_5_8 >> imm5u; }
    :SUBI45  R4_5_8, imm5u is op9_14=0b000111 & R4_5_8 & imm5u { R4_5_8 = R4_5_8 - imm5u; }

########## V2 Baseline
    with : $(XWI37SP) {
        sprel: [+rel] is imm7u [rel = imm7u << 2;] { local addr:4 = sp + rel; export addr; }
        :LWI37.sp R3_8_10, sprel is R3_8_10 & lwi37=0 & sprel { R3_8_10 = *:4 sprel; }
        :SWI37.sp R3_8_10, sprel is R3_8_10 & lwi37=1 & sprel { *:4 sprel = R3_8_10:4; }
    }
    :ADDI10.sp imm10s is op10_14=0b11011 & imm10s { sp = sp + imm10s; }

########## V3 Baseline
    imm8u_5: imm is imm5u [imm = imm5u << 3;] { export *[const]:4 imm; }
    imm8u_6: imm is imm6u [imm = imm6u << 2;] { export *[const]:4 imm; }

    :ADDRI36.sp R3_6_8, imm8u_6 is op9_14=0b011000 & R3_6_8 & imm8u_6 { R3_6_8 = sp + imm8u_6; }
    :ADD5.pc R5_0_4 is op5_14=0b1011101101 & R5_0_4 { R5_0_4 = inst_start + R5_0_4; }
    with : $(MISC33) {
        :AND33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b110 { R3_6_8 = R3_6_8 & R3_3_5; }
        :MUL33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b100 { R3_6_8 = R3_6_8 * R3_3_5; }
        :NEG33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b010 { R3_6_8 = -R3_3_5; }
        :NOT33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b011 { R3_6_8 = ~R3_3_5; }
        :OR33   R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b111 { R3_6_8 = R3_6_8 | R3_3_5; }
        :XOR33  R3_6_8, R3_3_5 is R3_6_8 & R3_3_5 & subop0_2=0b101 { R3_6_8 = R3_6_8 ^ R3_3_5; }
    }
    with : $(BFMI333) {
        :BMSKI33 R3_6_8, imm3u is R3_6_8 & imm3u & subop0_2=0b110 { R3_6_8 = R3_6_8 & (1 << imm3u); }
        :FEXTI33 R3_6_8, imm3u is R3_6_8 & imm3u & subop0_2=0b111 { R3_6_8 = R3_6_8 & ((1 << (imm3u + 1)) - 1); }
    }
    # imm7n shall be in range [-128,-4]
    imm7n: imm is imm5u [imm = (imm5u - 32) << 2;] { export *[const]:4 imm; }
    :LWI45.FE R4_5_8, [imm7n] is op9_14=0b011001 & R4_5_8 & imm7n {
        R4_5_8 = *:4 (s2 + imm7n);
    }
    :MOVD44 R4_4_7, R4_0_3 is op8_14=0b1111101 & R4_4_7 & R4_0_3 {
        local rt1:4 = &R4_4_7;
        local rt2:4 = rt1 + 4;
        local ra1:4 = &R4_0_3;
        local ra2:4 = ra1 + 4;
        *[register]:4 rt1 = *[register]:4 ra1;
        *[register]:4 rt2 = *[register]:4 ra2;
    }
    imm6u_5: imm is imm5u [imm = imm5u + 16;] { export *[const]:4 imm; }
    :MOVPI45 R4_5_8, imm6u_5  is op9_14=0b111101 & R4_5_8 & imm6u_5 { R4_5_8 = imm6u_5; }

    macro push_reg(ri) {
        sp = sp - 4;
        *:4 sp = ri;
    }
    macro push25_epilog_0() { push_reg(s0); }
    macro push25_epilog_2() {
        push_reg(s2);
        push_reg(s1);
        push25_epilog_0();
        # store function entry point in r8
        # only implicitly used by LWI45.FE
        # NOT done for Re == 0
        s2 = inst_start & 0xfffffffc;
    }
    macro push25_epilog_4() { push_reg(s4); push_reg(s3); push25_epilog_2(); }
    macro push25_epilog_8() { push_reg(s8); push_reg(s7); push_reg(s6); push_reg(s5); push25_epilog_4(); }
    push25_re: R2_5_6 is R2_5_6 & R2_5_6=0 { push25_epilog_0(); }
    push25_re: R2_5_6 is R2_5_6 & R2_5_6=1 { push25_epilog_2(); }
    push25_re: R2_5_6 is R2_5_6 & R2_5_6=2 { push25_epilog_4(); }
    push25_re: R2_5_6 is R2_5_6 & R2_5_6=3 { push25_epilog_8(); }
    :PUSH25 push25_re, imm8u_5    is op7_14=0b11111000 & push25_re & imm8u_5 {
        push_reg(lp);
        push_reg(gp);
        push_reg(fp);
        build push25_re;
        sp = sp - imm8u_5;
    }
    macro pop_reg(ri) {
        ri = *:4 sp;
        sp = sp + 4;
    }
    macro pop25_prologue_0() { pop_reg(s0); }
    macro pop25_prologue_2() { pop25_prologue_0(); pop_reg(s1); pop_reg(s2); }
    macro pop25_prologue_4() { pop25_prologue_2(); pop_reg(s3); pop_reg(s4); }
    macro pop25_prologue_8() { pop25_prologue_4(); pop_reg(s5); pop_reg(s6); pop_reg(s7); pop_reg(s8); }
    pop25_re: R2_5_6 is R2_5_6 & R2_5_6=0 { pop25_prologue_0(); }
    pop25_re: R2_5_6 is R2_5_6 & R2_5_6=1 { pop25_prologue_2(); }
    pop25_re: R2_5_6 is R2_5_6 & R2_5_6=2 { pop25_prologue_4(); }
    pop25_re: R2_5_6 is R2_5_6 & R2_5_6=3 { pop25_prologue_8(); }
    :POP25  pop25_re, imm8u_5    is op7_14=0b11111001 & pop25_re & imm8u_5 {
        sp = sp + imm8u_5;
        build pop25_re;
        pop_reg(fp);
        pop_reg(gp);
        pop_reg(lp);
        psw_ifcon_clear();
        return [lp];
    }

########## EX9IT Extension

    # indirect instruction execution from Instruction_Table
    :EX9.IT imm9u is op9_14=0b110101 & imm9u     { ex9it(imm9u:2); }
    :EX9.IT imm5u is op5_14=0b1011101010 & imm5u { ex9it(imm5u:1); }

########## DSP ISA Extension

    imm9s_rel: rel is imm9s [ rel = inst_start + (imm9s << 1); ] { export *:4 rel; }
    :IFCALL9 imm9s_rel is op10_14=0b11110 & imm9s_rel {
        ifcall(imm9s_rel);
    }
    # Special case of MOV55 encoding (Rt=sp, Ra=sp)
    :IFRET16 is op10_14=0b00000 & R5_5_9=0b11111 & R5_0_4=0b11111 {
        ifret();
    }
}
